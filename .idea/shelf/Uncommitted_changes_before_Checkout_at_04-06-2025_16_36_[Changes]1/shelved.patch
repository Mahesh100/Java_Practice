Index: Java Theory/Java Notes
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>\r\n# Java : Java is programming language which is used to develop various applications like desktop, web, stand alone applications\r\n         It is secure programming language which supports various features like oops,collections, multithreading etc.\r\n\r\n   OOPS : Object Oriented Programming System.\r\n\r\n\r\n## Object class is the parent class of all the classes in java.\r\n\r\n# Primitive variable like int a =10;  String s =\"abc\" doesn't hold any reference it just store value itself.  //Being variables in java\r\n\r\n# String Constant Pool (SCP) is present in Heap Memory Area.\r\n\r\n# Object are stored in Heap area but reference is created Stack area.\r\n\r\n   i) The object is stored in the heap.\r\n   ii) Reference is stored in stack which point to an object in heap.\r\n\r\n# Once the code execution get completed, the references from the stack area get deleted/clear\r\n\r\n# Lambada Expression are usually passed as a parameters to functions.\r\n\r\n# The main objective of introducing lambada expression in java is to bring functional programming feature in java.\r\n  As java is Object oriented programming language which doesn't supports functional programming features (But other languages already supports functional programming features)\r\n\r\n# To invoke Lambada expression we need functional interface.\r\n  To call the lambada expression we use only functional interface.\r\n\r\n# The super keyword can be used to call a method on the superclass of the current class.\r\n  -The super keyword refers to superclass (parent) objects. It is used to call superclass methods, and to access the superclass constructor.\r\n\r\n# Static block is used for static initialization of classes\r\n\r\n# code inside the static block is executed only once: the first time the class is loaded into memory.\r\n\r\n# Duplicate constructor is not allowed in class, we have to overload it.\r\n\r\n# We can overload constructor\r\n\r\n# Constructor is also use to initialise the class variables/Instance variables.\r\n\r\n# \"this\" keyword is used when we have to initialise the class variables or instance variables.\r\n\r\n# Whenever we create object of sub class it will call the constructor of Super(Parent) class as well as sub(Child) class\r\n\r\n# \"break\" statement is used to jump out off the loop\r\n\r\n# \"continue\" statement breaks the one iteration in loop if specified condition occur and continue with the next iteration of loop\r\n\r\n# By default maximum heap size is 64 Mb\r\n\r\n# compareTo() method in java is used to compare two string lexicographically.\r\n\r\n# *Static method in java can not be overridden\r\n   (Static method belongs to a class not a instances and hence can not be overridden in sub class)\r\n\r\n\r\n# Reflection in java\r\n-\r\n\r\n----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\r\n----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\r\n\r\n# Instance Variable in java\r\n\r\n- In Java, an instance variable is a variable declared within a class but outside any method, constructor, or block.\r\n  It's called an \"instance\" variable because its value is unique to each instance (object) of the class.\r\n\r\nIn java, instance variable are used for several reasons\r\n\r\n- Instance variable are used to define properties and attributes of an object\r\n- By declaring the instance variable private we can control the access of instance variable from out side of class (Data Encapsulation).\r\n\r\n----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\r\n----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\r\n# Class loader in java\r\n\r\n- In Java, a class loader is a part of the Java Runtime Environment (JRE) responsible for dynamically loading Java classes into the Java Virtual\r\n  Machine (JVM) during runtime.\r\n- This means that classes are loaded only when they are needed, not all at once when the program starts.\r\n\r\n----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\r\n----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\r\n\r\n # Access modifiers in java\r\n\r\n   1) Public\r\n   2) Private\r\n   3) Protected\r\n   4) Default\r\n\r\n  1) Public access modifiers mean that the class, method, or variable can be accessed from\r\n     anywhere in the program.\r\n\r\n  2) Private access modifiers mean that the class, method, or variable can only be\r\n     accessed from within the same class.\r\n\r\n  3) Protected access modifiers mean that the class, method, or variable can be\r\n     accessed from within the same package and by subclasses of the class.\r\n\r\n  4) Default access modifiers mean that the class, method, or variable can\r\n     be accessed from within the same package.\r\n\r\n----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\r\n----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\r\n\r\n\r\n# Different Types of Variables in Java\r\n\r\n 1) Local Variables\r\n 2) Instance Variables\r\n 3) Static Variables\r\n\r\n 1) Local Variable:  (Declared Inside the method body)\r\n     -A variable defined within block of code, method or constructor is called local variable in java.\r\n\r\n     -These variables are created when execution is enters into the block of code or method is called\r\n       and destroyed when execution comes out off block of code.\r\n\r\n     -The scope of this variables are only withing the block of code in which the variables are declared.\r\n\r\n     - Initialization of local variable is mandatory before using it in defined scope.\r\n\r\n  2) Instance Variable:  (Declared outside the method and inside the class)\r\n\r\n       - Instance variable are non-static variables which declared outside of any method, constructor or block\r\n       - Instance variables can be accessed only by creating objects.\r\n       - We initialize instance variables using constructors while creating an object.\r\n       - We can also use instance blocks to initialize the instance variables.\r\n\r\n  3) Static Variables:\r\n      - Variables which are declared using static keyword are called static variables in java.\r\n      - Static variables are used for memory management\r\n\r\n   the static variable is initialized before the instance variable,\r\n   and the instance variable is initialized before the local variable.\r\n\r\n   Static -> Instance -> Local\r\n\r\n  Class TypeOfVariables{\r\n\r\n       Static int c =30;\r\n\r\n       int a = 10; //instance variable\r\n\r\n       public static void main(String [] args)\r\n       {\r\n           int b =20;   //Local Variable\r\n\r\n\r\n           System.out.println(b);\r\n           System.out.println(c);\r\n\r\n           TypeOfVariables obj = new TypeOfVariables();\r\n\r\n            System.out.println( obj.a);\r\n       }\r\n\r\n  }\r\n----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\r\n----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\r\n# Looping in java\r\n\r\n # While Loop\r\n\r\n  -While loop is pre-test loop\r\n  -It check the condition first before execution enters into body of loop\r\n  -While loop is used when we don't know the number of iterations in advanced.\r\n  -While loop is also known as entry control loop\r\n\r\n # Syntax\r\n\r\n   while(condition)  //if condition is true\r\n   {\r\n    //statement\r\n   }\r\n\r\n   #Flow chart\r\n\r\n                        Start\r\n                          |\r\n                          |\r\n                  |---Condition     //Until condition true\r\n                  |       |  (True)\r\n                  |       |\r\n                  -----Statement\r\n\r\n\r\n----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\r\n  # Do While loop\r\n\r\n  - Do while loop is post test loop\r\n  - Here we first execute the statement/code block then it will check the condition.\r\n  - Do while loop is used when we want to execute loop body at least once even condition is false\r\n  - It is also known as exit control loop.\r\n\r\n\r\n  #Syntax\r\n\r\n  do\r\n  {\r\n  // Statement\r\n  }\r\n  while(Condition);\r\n\r\n   #Flow chart\r\n\r\n                        Start\r\n                          |\r\n                          |\r\n                  |---Statement\r\n                  | (True)|  (True)\r\n                  |       |\r\n                  ----Condition\r\n                          | (False)\r\n                          |\r\n                         End\r\n\r\n----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\r\n----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\r\n\r\n\r\n# Constructor in Java\r\n\r\n- Constructor is block of code having same name as that of class name.\r\n- The main purpose of Constructor is to initialize the object in java\r\n- Every java class has a default constructor\r\n- A constructor is automatically called at the time of object creation\r\n- Constructor does not have any return type.\r\n\r\n- \"this\" keyword is used in constructor\r\n    -To call another constructor in the same class\r\n    -To refer to the current class instance\r\n\r\n- 4 Types of constructor in java\r\n\r\n -private constructor\r\n -default constructor\r\n -parametrized constructor\r\n -copy constructor\r\n\r\n # *Constructor chaining in java\r\n    Calling one constructor from another constructor withing the same class using this() method.\r\n\r\n # We can call one constructor from another constructor by two ways\r\n\r\n - this() keyword : Using this() keyword\r\n\r\n  -super() keyword : Using super() keyword\r\n\r\n-Syntax\r\n\r\n    class ClassName()\r\n    {\r\n    className();\r\n    }\r\n\r\n----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\r\n----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\r\n\r\n# this keyword in java\r\n - this keyword in java returns the current class instance/object\r\n -  we can not use this inside static method.\r\n - this keyword represents the current object of the class.\r\n - this keyword is used to initialize the class variables or instance variables\r\n - this can be used to refer current class method\r\n - this can be used to invoke current class constructor\r\n -\r\n\r\n----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\r\n\r\n# Super keyword in java\r\n\r\n- Super keyword refers the object of super class\r\n- Super keyword is used when we want to call the variable,method,constructor from super class using the sub class object\r\n\r\n- When to use :\r\n  -Super keyword is used only when the variable, method and constructor of sub class and super clas are same.\r\n  -To avoid the confusion between super class and sub class variables and methods that have same name we should use super keyword\r\n\r\n- Every constructor in sub class have the super() method by default.\r\n\r\n# Syntax\r\n\r\n  # Calling variable of super class using sub class object\r\n\r\nclass A {     //super class\r\n\r\n  int a = 20;\r\n\r\n}\r\n\r\nclass B extends A  // sub class\r\n{\r\n  int a =10;\r\n  void show()\r\n  {\r\n    System.out.println(a);\r\n    System.out.println(super.a);\r\n  }\r\n\r\n   public static void main(String [] args)\r\n   {\r\n        B obj = new B();\r\n        obj.show();\r\n   }\r\n}\r\n\r\n# To do (Super keyword for methods)\r\n\r\n\r\n\r\n----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\r\n----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\r\n\r\n # Advantage of Java 11 over java 8\r\n\r\n -Java 11 includes a number of performance improvements, such as a new garbage collector called ZGC and\r\n  a new HTTP client. These improvements can make Java applications run faster and more efficiently.\r\n\r\n -Java 11 is a long-term support (LTS) release, which means that it will be supported by Oracle for at least eight years.\r\n -Java 11 applications can start up to 25% faster than Java 8 applications.\r\n\r\n\r\n# New Features in java 11\r\n\r\n\r\n----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\r\n----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\r\n\r\n# Static Blocks in java\r\n\r\n- Static blocks or static initialise blocks are used to initialise static fields in java\r\n\r\n- Static blocks are get executed exactly once when the class is loaded\r\n- Whenever the JVM loads the class, static blocks get executed.\r\n- Class can have any number of static blocks.\r\n- The order of execution of the static blocks depends on the order of static block\r\n  placed in given code.\r\n- Static block get executed even before the constructor of the class get executed.\r\n\r\n- Static keyword is a powerful tool that can be used to improve the memory management,\r\n  efficiency, and organization of your Java code.\r\n\r\n----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\r\n----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\r\n# StringBuffer in java\r\n\r\n- StringBuffer is mutable in nature\r\n- StringBuffer is thread safe\r\n- StringBuffer implements Serializable and CharSequence interfaces\r\n- The principal operation for StringBuffer is to append and insert methods\r\n- The append() method will always add the object at the end of buffer\r\n- The insert() method adds the object at specific point\r\n\r\n\r\n----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\r\n----------------------------------------------------------   OOPS CONCEPT  -----------------------------------------------------------------------------------------------------------------------------------\r\n\r\n1] Inheritance in Java\r\n\r\n  - Inheritance in java is mechanism by which one class acquires all the properties and behavior of another class is called inheritance\r\n\r\n  - Inheritance represents Is-A relationship which is also known as parent child relationship.\r\n  - For Method overriding inheritance is used (To achieve runtime polymorphism)\r\n  - Inheritance is used for code reusability.\r\n  - \"extends\" keyword is used to achieve the inheritance\r\n\r\n  - In java Single, multilevel and hierarchical inheritance are present in java\r\n  - Multilevel and Hybrid inheritance is achieved using interface only.\r\n\r\n\r\n----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\r\n----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\r\n\r\n2] Abstraction\r\n\r\n- Abstraction in java is mechanism by which we can hide the implementation details and shows only essential details of the class to the user\r\n\r\n- If method in a class don't have body then it must be declared as abstract\r\n\r\n      abstract void start();\r\n\r\n - A method without body (No implementation) is known as Abstract methods.\r\n\r\n - If class have any abstract method then class should be mark with abstract Keyword.\r\n\r\n - Abstract classes can not be instantiated, we can not create object of an abstract class.\r\n\r\n----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\r\n----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\r\n\r\n\r\n3] Polymorphism in java\r\n - Polymorphism is commonly achieved in java by method overriding (run time polymorphism) and method over loading (Compile time polymorphism)\r\n\r\n----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\r\n----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\r\n4] Encapsulation In Java\r\n\r\n - Encapsulation in java is mechanism by which we can wrap/bind data members and member function together in single class\r\n   is called Encapsulation.\r\n\r\n - In order to achieve Encapsulation\r\n     -data members/fields should be private\r\n     -Member function/methods should be public in nature.\r\n\r\n - Any class in java is best example of Encapsulation in java.\r\n\r\n - Encapsulation prevents outer classes from accessing and changing fields and methods of a class.\r\n   This also helps to achieve data hiding.\r\n\r\n# Getters and Setters in java\r\n\r\n   - In Java, Getters and Setters are the methods that provide controlled to access fields/variables of a class.\r\n     Getters and Setters are the fundamental part of the encapsulation principle in object oriented programming.\r\n\r\n   - A getter method retrieves (gets) the value of a private field.\r\n   - A setter method sets (updates) the value of a private field.\r\n\r\n  - To protect the data in class getters and setters are used.\r\n  - We can say that getter and setter are used to achieved encapsulation in class.\r\n  - We have to provide the public get and set methods to access and update the value of private variable in class.\r\n  - The get method returns the value of variable and set method will set the value of variable.\r\n  - To update the private class variables outside from the class we can use getters and setters.\r\n\r\n\r\nWhy Do We Need Getters and Setters?\r\n\r\nEncapsulation: By making fields private and providing public getter and setter methods, we can control how the fields are accessed and modified.\r\n               This ensures that the internal representation of the object is hidden from the outside.\r\n\r\nValidation: Setters can include validation logic to ensure that the fields are set to appropriate values.\r\n            This helps in maintaining the integrity of the object.\r\n\r\n----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\r\n----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\r\n\r\n# Interface in java\r\n\r\n- The mechanism to achieve abstraction is known as interface.  (-Interface is used to achieve abstraction.)\r\n- We can not create object of interface.\r\n- Interface supports multiple inheritance/ Interface used to implement multiple inheritance\r\n- Interface used to achieve loose coupling.  (IMP)\r\n- Interface is the blue print of the class which tells class what to do, but it does not show/tell class how to implement a particular task\r\n- We can not create concerete methods in interface\r\n- All the methods in interface are  \" public abstract \" types\r\n- All the fields/variables in interface are by default \"public static final\" ;\r\n\r\n\r\n- Interface supports multiple inheritance\r\n\r\n--->>>> In java 8 version\r\n\r\n- We can create default conerate methods\r\n\r\n     default void display() {\r\n        System.out.println(\"Display\");\r\n     }\r\n\r\n  - We can create static methods inside interface.\r\n\r\n     static void run(){\r\n     System.out.println(\"I am running\");\r\n     }\r\n\r\n--->>>> In java 9 version\r\n\r\n -In java 9 version we can use\r\n private void run() {\r\n\r\n }\r\n# Syntax\r\n\r\ninterface InterfaceName {\r\n\r\n  public abstract method();\r\n\r\n  public static final filedName;\r\n}\r\n\r\n----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\r\n\r\n # Difference between Abstract class and Interface\r\n\r\n 1) Abstract class can have Abstract and non abstract methods.\r\n 2) Abstract class doesn't support multiple inheritance.\r\n 3) Abstract class can have final, non-final , static and non-static variables.\r\n 4) Abstract class can provide implementation of interface.\r\n 5) Abstract class can be declared using 'Abstract' keyword.\r\n 6) Abstract class can be extended using 'extend' keyword.\r\n\r\n\r\n 1) Interface can only have abstract methods. From java 8 we can use default and static methods and from\r\n    Java 9 we can use private methods in interface\r\n 2) Interface supports multiple inheritance.\r\n 3) Interface only have static and final variables.\r\n 4) Interface can not provide implementation of interface\r\n 5) Interface can be declared using 'Interface' keyword.\r\n 6) Interface can be implemented using 'Implement' keyword.\r\n\r\n\r\n ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\r\n # When to use Abstract class and when to use Interface in java\r\n\r\n Abstract Class\r\n 1) share code among the related classes,\r\n 2) if require access modifier other than public (like protected & private)\r\n 3) if you want to declare non-static or non-final fields.\r\n\r\n 4) If we know partial implementation of the class but not complete implementation then abstract class is good choice\r\n\r\n Interface\r\n 1) Implements interface with unrelated classes such as Serializable, Cloneable\r\n 2) If you want to take advantage of multiple inheritance\r\n\r\n Note: many classes use both abstract classes and interfaces like HashMap class\r\n implements several interface and also extends abstract class AbstractMap\r\n\r\n----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\r\n\r\n# Marker Interface\r\n\r\n -An interface which does not contain any field, method or constants is called marker interface.\r\n -The Serializable and Cloneable interfaces are the example of marker interface.\r\n\r\n -It provides run-time type information about objects, so the compiler and JVM have additional information about the object.(tagging interface.)\r\n\r\n Marker interface is used as a tag  information to the Java compiler or a message so that it can add some special\r\n behavior to the class implementing it. Java marker interface are useful if we have information about the class\r\n and that information never changes, in such cases, we use marker interface to represent the same.\r\n Implementing an empty interface tells the compiler to do some operations.\r\n\r\n----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\r\n\r\n# Callable Interface in java\r\n\r\n-The Callable interface in Java is a functional interface that defines a single method, call() method - which returns a value.\r\n-The value can be obtained through Future<V> objects.\r\n-In order to Return the result we use callable interface.\r\n\r\n-Callable is similar to Runnable, but it can return a result and can throw checked exceptions\r\n-Runnable cannot throw checked exceptions and does not return a result.\r\n\r\n----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\r\n----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\r\n\r\n # Serialization in java\r\n\r\n - The process of converting object into series of bits is called serialization in java.\r\n\r\n - The object must be serialize to do following operations :\r\n\r\n    1) Writing a object to a file\r\n    2) Reading an object from file\r\n    3) Writing an object to a network\r\n    4) Reading an object to a network.\r\n\r\n  - Class must implement java.io.serializable interface to make suitable object  (Marker interface)\r\n\r\n  - In Java, a serialVersionUID is a unique identifier for each Serializable class that is used to verify\r\n   that the saved object and the loaded class are compatible.\r\n\r\n----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\r\n----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\r\n\r\n# Exception in java\r\n\r\n1) Any unwanted or unexpected event which disturbs the normal flow and execution of program is called Exception.\r\n\r\n    -At compile time exception never occurs, all the exception occurs at the runtime.\r\n\r\n # Exception :\r\n-Exception occurs because of program\r\n-Exceptions are recoverable / We can handle the exception.\r\n-Exception are of two types :\r\n   i)  Compile time exception (Checked exception )      //Remember both starts with C\r\n   ii) Runtime exception     (Unchecked exception)\r\n\r\n # Error\r\n-Error occurs because of lack of resources.(System ram)\r\n-Errors are not recoverable / Errors can not be handled\r\n-Error is only of single type -Runtime exception (Unchecked exception)\r\n\r\n2) Difference between Checked exception and Unchecked exception\r\n\r\n   i)  Checked Exception : (Compile time exception)\r\n       - Checked exception are the exception which are checked and handle at the compile time.\r\n       - Checked exception must be caught or declared using throws keyword\r\n       - Checked exception handle using try-catch block or throws keyword.\r\n       - When checked exception occurs, program flow is interrupted and transfer to catch block.\r\n       - Examples :\r\n           -ClassNotFoundException\r\n           -IoException\r\n\r\n\r\n   ii) Unchecked Exception : (Runtime exception)\r\n       - Unchecked exception are the exception which are not handle at compile time.\r\n       - Unchecked exception do need to required handle explicitly.\r\n       - When unchecked exception occurs program flow is halted with an error message.\r\n       - Examples:\r\n            -ArrayIndexOutOfBoundException\r\n            -NullPointerException\r\n\r\n\r\n\r\n2) Exception hierarchy\r\n\r\n                                                                Object  (Object is parent class of all classes in java)\r\n                                                                  |\r\n                                                                  |\r\n                                                              Throwable\r\n                                                                  |\r\n                                                                  |\r\n                                              -------------------------------------------------------\r\n                                              |                                                     |\r\n                                              |                                                     |\r\n                                          Exception                                               Error\r\n                                      (Because of program)                                 (Because of System Resources)\r\n                                             |                                                      |\r\n                                             |                                                  Unchecked exception (Runtime exception)\r\n                      -------------------------------------------------------\r\n                      |                                                     |\r\n                      |                                                     |\r\n                Checked Exception                                   Unchecked Exception\r\n                (Compile Time exception)                            (Runtime Exception)\r\n\r\n\r\n\r\n\r\n-  A subclass can only throw the same exception or a narrower (more specific) exception than the one declared in the parent class method.\r\n-  This is to ensure that the caller of the method is not surprised by a broader exception than they were expecting.\r\n\r\n----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\r\n----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\r\n\r\n\r\n # Difference between Final , Finally and Finalize in java\r\n\r\n   # Final\r\n   - In Java, final is non-access modifier used to restrict modification\r\n   - When you define final variable, method or class its value can not be changed\r\n   - Final is key word in java.\r\n   - Final keyword can be used with\r\n       - Variables\r\n       - Methods\r\n       - Classes\r\n\r\n\r\n   # Finally\r\n   - Finally is block in java.\r\n   - Finally block is used along with try-Catch blocks\r\n   - Finally block always executed irrespective of the exception will occurs in try block or not\r\n   - In finally block we always write cleanup code.\r\n      - Closing DB connections\r\n      - Closing open files\r\n      - To close used resources finally block is used.\r\n\r\n   - There can only be one finally block, and it must follow the catch blocks.\r\n\r\n   # Finalize\r\n   - Finalize is method in java.\r\n   - Finalize method is called by garbage collector to destroy unused objects.\r\n   - Finalize method is used to write clean up codes.\r\n\r\n\r\n----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\r\n----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\r\n\r\n# Aggregation in java\r\n\r\n- Aggregation is a type of association between classes.\r\n- In java, aggregation represents \"has-a\" relationship between two classes,\r\n  where one class contains reference to the another class\r\n\r\n- Reference class object can exists independently to the Container class object\r\n\r\n\r\n# Composition in java\r\n\r\n- In Java, composition is type of association between classes where one class contains the object of\r\n  another class\r\n- Composition represents the stronger relationship where contained object can not exists independently of\r\n  the container object\r\n\r\n ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\r\n ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\r\n # Multitasking in java\r\n\r\n - Performing multiple task at single time.\r\n -\r\n # Multithreading in java.\r\n\r\n - For the Maximum utilization of CPU/Memory java allows concurrent execution of two or more parts of program\r\n   this feature in java is called Multithreading in java.\r\n -\r\n\r\n - Multithreading is feature in java that allows concurrent execution of two or more part of program for maximum utilization cpu/memory.\r\n - Each part of such program is called thread\r\n - So threads are light weight processes within the process.\r\n\r\n - A thread is a light weight subprocess that allow you to perform multiple task concurrently within the same application.\r\n\r\n - In Java, a Process represents an executing program or application.\r\n\r\n Threads can be created by using two mechanism :\r\n\r\n  1) By extending thread class (Thread class present in java.lang package)\r\n  2) By implementing runnable interface.\r\n\r\n  // Java code for thread creation by extending\r\n  // the Thread class\r\n\r\n  class MultithreadingDemo extends Thread {\r\n  \tpublic void run()\r\n  \t{\r\n  \t\ttry {\r\n  \t\t\t// Displaying the thread that is running\r\n  \t\t\tSystem.out.println(\r\n  \t\t\t\t\"Thread \" + Thread.currentThread().getId()\r\n  \t\t\t\t+ \" is running\");\r\n  \t\t}\r\n  \t\tcatch (Exception e) {\r\n  \t\t\t// Throwing an exception\r\n  \t\t\tSystem.out.println(\"Exception is caught\");\r\n  \t\t}\r\n  \t}\r\n  }\r\n\r\n  // Main Class\r\n\r\n  public class MultiThread {\r\n  \tpublic static void main(String[] args)\r\n  \t{\r\n  \t\tint n = 8; // Number of threads\r\n\r\n  \t\tfor (int i = 0; i < n; i++) {\r\n  \t\t\tMultithreadingDemo object\r\n  \t\t\t\t= new MultithreadingDemo();\r\n  \t\t\tobject.start();\r\n  \t\t}\r\n  \t}\r\n  }\r\n\r\n\r\n-> We can not start thread twice\r\n- This will throw illegalThreadStateException\r\n\r\n - Threads will use methods such as wait(), notify() and notifyAll() to communicate with each other\r\n\r\n # Dead Lock In Java\r\n\r\n - If two threads are waiting for each other forever such situation is called Dead lock in java.\r\n\r\n - If Thread1 holding object 1 and Thread2 holding object 2 but Thread1 is waiting for object2 and Thread2 is waiting for object1 forever then we can say\r\n   that Thread1 and Thread2 are in dead lock condition.\r\n\r\n - There is no complete re-solution for solving dead lock in java but several prevention techniques are possible.\r\n - Synchronized keyword is cause of dead lock in java, we have to use synchronised keyword carefully\r\n\r\n----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\r\n\r\n-The wait() method is provided by the Object class in Java.This method is used for inter-thread communication in Java.\r\n\r\n The java.lang.Object.wait() is used to pause the current thread,\r\n and wait until another thread does not call the notify() or notifyAll() method.\r\n Its syntax is given below.\r\n\r\n  public final void wait();\r\n\r\n\r\n wait()\r\n 1) The wait() method is defined in Object class.\r\n 2) The wait() method releases the lock.\r\n\r\n sleep()\r\n 1)The sleep() method is defined in Thread class.\r\n 2)The sleep() method doesn't release the lock.\r\n\r\n----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\r\n  # Advantages of multithreading\r\n\r\n  -Multithreading allows the faster execution of tasks, as threads execute independently.\r\n  -Multithreading provides better utilization of cache memory as threads share the common memory resources.\r\n  -Multithreading reduces the number of the required server as one server can execute multiple threads at a time.\r\n\r\n\r\n----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\r\n # Thread LifeCycle\r\n\r\n A thread can have one of the following states during its lifetime:\r\n\r\n - New             :   In this state, a Thread class object is created using a new operator, but the thread is not alive.\r\n                       Thread doesn't start until we call the start() method.\r\n\r\n - Runnable        :   In this state, the thread is ready to run after calling the start() method.\r\n                       However, the thread is not yet selected by the thread scheduler.\r\n\r\n - Running         :   In this state, the thread scheduler picks the thread from the ready state,\r\n                       and the thread is running.\r\n\r\n - Waiting/Blocked :   In this state, a thread is not running but still alive, or it is\r\n                        waiting for the other thread to finish.\r\n\r\n - Dead/Terminated :    A thread is in terminated or dead state when the run() method exits.\r\n\r\n\r\n\r\n\r\n\r\n-The Synchronized block can be used to perform synchronization on any specific resource of the method.\r\n Only one thread at a time can execute on a particular resource, and all other threads\r\n which attempt to enter the synchronized block are blocked.\r\n\r\n----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\r\n\r\n# Volatile keyword in java\r\n\r\n- Volatile keyword is used in java to indicate that the variables value can be modified by different threads.\r\n- Volatile keyword ensures that the changes made to the volatile variable by one thread are immediately visible to another thread.\r\n\r\n- The values of volatile variables never be cached.\r\n- Value of volatile keyword never read from cached but it is always read from the main memory.\r\n\r\nFor Example (Scenario)\r\n\r\n- Suppose we have two threads Thread-1 and Thread-2 and there is one shared variable of type Boolean which stored in main memory RAM of system.\r\n  Now these two threads interact with CPU and CPU interact with RAM and we have cache between CPU and RAM of both threads which reduces the\r\n  access time of values\r\n\r\n  so, whenever we have shared variable which exits in memory where multiple threads are trying to access the same variable and work on it depending\r\n  up on requirements. Initially the value of shared variable is stored as True in both the cache as well as memory\r\n\r\n  Now, we know that this two threads does not read the value of shared variable directly from the memory but instead read locally from their respective\r\n  cache memory.\r\n\r\n  Now suppose thread-2 changes the value of variable as false and it is updated in cache memory, but for other thread-1 the value is still true in its\r\n  cache memory and in main memory. So thread-2 will take some time to update the value of variable in main memory as false\r\n  but still thread-1 don't have any visibility that value is false so this will create a problem.\r\n\r\n  So,to overcome this problem java introduced volatile keyword\r\n  so volatile boolean True;\r\n  so now Thread-1 and Thread-2 directly read value from main memory instead of cache.\r\n  If in case Thread-2 will change the value of shared variable as false then Thread-1 will have access to it instantly.\r\n  This is how volatile keyword is used in java.\r\n----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\r\n----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\r\n\r\n\r\n  # Generics in java\r\n\r\n  - In Generics everything is happen at compilation level.\r\n\r\n----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\r\n----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\r\n\r\n# Cursors/Iterator\r\n  - Iterator in java are used to iterate over the collection objects\r\n -If we want to print element in collection one by one then we have to use Cursors\r\n\r\n Types of Cursors :\r\n\r\n 1] Iterator\r\n 2] ListIterator\r\n 3] Enumeration\r\n\r\n # Iterator in Java\r\n\r\n - The object which is used to loop through a collection like ArrayList and HashMap is called Iterator\r\n\r\n - The iterator() method is used to get iterator for any collection.\r\n\r\n\r\n  * Difference between Iterator and ListIterator\r\n\r\n\r\n\r\n  # Iterator\r\n\r\n       List list = new ArrayList();\r\n\r\n       Iterator it = list.iterator();\r\n\r\n  1] We can get the Iterator cursor using .iterator() method.\r\n  2] Iterator cursor can be used with any collection objects\r\n  3] In iterator method we have methods like\r\n         next()\r\n         hasNext()\r\n         remove()    methods\r\n  4] Using Iterator cursor we can retrieve elements using only forward direction.\r\n  5] By using Iterator cursor we can only retrieve and remove elements.\r\n\r\n\r\n\r\n\r\n\r\n  # ListIterator\r\n\r\n  1] We can get ListIterator cursor using .listIterator() method\r\n  2] ListIterator can be used only with list implemented classes.  i.e ArrayList, LinkedList, Vector, Stack.\r\n  3] In ListIterator we have methods as :  (total 6)\r\n                next()\r\n                hasNext()\r\n                hasPrevious()\r\n                previous()\r\n                remove()\r\n                set()\r\n\r\n  4] Using ListIterator cursor we can retrieve collection elements in both forward and backward direction.\r\n  5] By using listIterator cursor we can retrieve, remove, replace and add collection elements.\r\n\r\n\r\n\r\n#  Enums in Java  (Enumeration)\r\n\r\n - Enumeration is special type of data type which is used to represents set of pre-define constants.\r\n - These constants typically related to fixed set of possible values of given concept.\r\n - Enum is special type of data type in java that can be used to represent the group of constants\r\n - Enum are useful when we have fixed set of values that are known at compile time\r\n - Enums make your code more readable and maintainable.\r\n\r\n\r\n----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\r\n----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\r\n\r\n   # Collection in java\r\n\r\n   - Collection is group of objects or group of elements\r\n   - To store the group of objects or group of elements we used collections\r\n\r\n\r\n  # Ways of Creating List in java\r\n\r\n  1) List<Integer> intList = new ArrayList<Integer>();\r\n\r\n         intList.add(1);\r\n         intList.add(2);\r\n         intList.add(3);\r\n         intList.add(4);\r\n\r\n\r\n  2) List<Integer> inList = Arrays.asList(1,2,3,4);\r\n   -Arrays.asList() in Java is mutable\r\n\r\n\r\n  3) List<Integer> inList = List.Of(1,2,3,4);\r\n   -List.of() is immutable\r\n\r\n\r\n\r\n----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\r\n----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\r\n\r\n\r\n---------------------------------------------------------------------- Functional Programming In Java -------------------------------------------------------------------------------\r\n\r\n # Lambada Expression\r\n\r\n   Objective :\r\n    - To bring functional programming features\r\n    - To improve Code optimization/we can write concise code\r\n\r\n - To bring the functional programming features in java, lambada expression is introduced in java 8\r\n\r\n - Using lambada expression we can achieve functional programming features in java.\r\n\r\n - Generally java is object oriented programming language.\r\n   The data will be stored in Classes  and Objects\r\n\r\n   But, in functional programming language the data will be stored in functions and variables\r\n\r\n - Lambada Expression is the anonymous function. It is function without name and it does not\r\n   belong to class or object.\r\n\r\n   # Definition :\r\n - Lambada expression is anonymous function which doesn't have name of method, return type and no return value, no access modifier.\r\n\r\n - Lambada Expression is mainly used for to implement Functional Interface.\r\n\r\n - Lambada expression is always associated with functional interface.\r\n\r\n\r\n General way of writing method in java :\r\n\r\n public void methodName(){\r\n\r\n    System.out.println(\"Welcome\");\r\n }\r\n\r\n  With Lambada expression:\r\n\r\nExample 1:\r\n\r\n   () -> {\r\n                 System.out.println(\"Welcome\");\r\n         }\r\n\r\n   () -> {System.out.println(\"Welcome\");}\r\n\r\n   More concise way\r\n\r\n   ()-> System.out.println(\"Welcome\");\r\n\r\n\r\nExample 2:\r\n\r\n    public void method2(int a, int b)\r\n        {\r\n            System.out.println(a+b);\r\n        }\r\n\r\n        (int a, int b) -> System.out.println(a+b);\r\n\r\n        More Concise way\r\n\r\n        (a,b)-> System.out.println(a+b);   //jvm automatically specifies type of variable based on\r\n                                           // on context at runtime\r\n\r\n\r\nExample 3:\r\n\r\n    public void method1(int a)\r\n     {\r\n        return(a*a);\r\n     }\r\n\r\n     (a)-> { return(a*a);};       //when use return statement it must be include in curly{ } braces.\r\n\r\n     more Concise way\r\n     (a) -> (a*a);   or  a -> a*a;\r\n\r\n\r\n----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\r\n\r\n # Functional Interface\r\n\r\n   # Default Functional Interfaces in java\r\n\r\n    1) Runnable interface  -----> run()     [method, only one abstract method]\r\n    2) Callable interface  -----> call()\r\n    3) Comparable interface ----> compareTo()\r\n    4) ActionListener       ----> actionPerformed()\r\n\r\n\r\n     - A interface which contains exactly one abstract method is called functional interface. (also contains default and static methods)\r\n\r\n     - Functional interface can contain any number of default and static methods.\r\n     - To call/invoke the lambada expression we need functional interface only\r\n     - Lambada expressions can be invoked using functional interface.\r\n     -\r\n----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\r\n\r\n# Without defining functional interface we can write lambada expression also : using:-\r\n\r\n      Using pre-define functional interface we can use lambada expression without functional interface\r\n\r\n    # Java 8 have some Predefine functional interfaces :\r\n\r\n                                            When to choose                                                                    Method\r\n    1) Predicate                       - When we have some conditional Checks in program                                   test() method\r\n    2) Function                        - To perform certain operation and return value                                     apply() method\r\n    3) Consumer                        - When we have to consume/use the provided input but doesn't return any value       accept() method\r\n    4) Supplier                        - It represents a function which does not take in any argument                      get() method\r\n                                         but produces a value of type T.\r\n\r\n    - These interface have one abstract method each\r\n    - These pre-define functional interface are present in java.util.function package\r\n\r\n  1) Predicate is one of the pre-define functional interface in java.\r\n     - It has abstract method called test();\r\n     - To check certain conditions in lambada expression we use Predicate.\r\n        interface Predicate(T)   //T=Type (argument)\r\n        {\r\n\r\n                public abstract boolean test(1 argument);\r\n\r\n        }\r\n\r\n           - Predicate<T> is as default lambada expression\r\n           - Predicate is an interface which contains only one abstract method which is test() abstract method which always contain single parameter\r\n           - Predicate return boolean value\r\n\r\n              Predicate<String> pr = s->(s.length()>4);\r\n              System.out.println(pr.test(\"Welcome\"));  //true\r\n\r\n           - Predicate always return boolean values either true or false\r\n           - Predicate is used only when we have conditional checks in your program.\r\n\r\n\r\n  2) Function Interface:\r\n\r\n     - Function interface have one abstract method as apply() method.\r\n     - apply() method take any type of parameter and will return single value\r\n     -\r\n\r\n     interface Function<T,R>     //T - Type and R- Return type\r\n     {\r\n         apply(Type);\r\n     }\r\n\r\n  # Function Chaining\r\n\r\n     - we can chain the function\r\n     - andThen() method  straight order execution\r\n     - compose() method  reverse order execution\r\n\r\n\r\n  3) Consumer Functional Interfaces\r\n\r\n     - Consumer have one abstract  method called accept()\r\n     - Consumer is just accept some input do some processing but doesn't return any value\r\n     -\r\n\r\n\r\n  4) Supplier Functional interface\r\n\r\n      - In case of supplier it doesn't take any input/argument but it do some action and return some object\r\n      - Supplier represents a function/method which does not take in any argument but produces a value of type T.\r\n----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\r\n----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\r\n# forEach method in java 8\r\n\r\n-\r\n\r\n----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\r\n----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\r\n # Stream API Java\r\n\r\n - Stream API is introduced in java 1.8 version\r\n\r\n - To processes the group of objects in collection we used Stream API concepts\r\n\r\n - Stream API is one of the way in java 8 by which we can achieve implementation of functional programming in java.\r\n - Stream API in java 8 is set of classes and interfaces which are used to work with sequence of elements in functional\r\n   and declarative way.\r\n\r\n - Stream API provides two different mechanism to process the data in collection as\r\n      1) filter\r\n      2) map\r\n\r\n - Stream API present in java.util package\r\n\r\n    1) filter :\r\n    - Suppose we have collection of objects as ArrayList have some integer objects\r\n       so if we use filter here then filter will filter data based up on certain condition and store it in some other collection\r\n\r\n    2) map :\r\n    -  Whatever data we have in collection that same data will be updated/modified and store in new targeted collection.\r\n\r\n   # Difference between filter and map in stream\r\n     1) In case of filter the data may be reduced\r\n     2) In case of map data will only get updated.\r\n\r\n    But we don't directly process data from the collection\r\n    We have stream , we will add all the objects from the collection to the stream and we will do all the operation on stream itself\r\n\r\n    - Here Stream is class in which different methods are available as filter, map.\r\n\r\n    Different methods available in stream class\r\n    -filter()                -map()               -sorted()              -count()       -reduce()\r\n\r\n    -collect()               -distinct()         -forEach()              -min()         -max()\r\n\r\n  - To process the data in the stream we use lambada expressions\r\n\r\n  1) filter() in stream class\r\n\r\n    - To process the data based up on certain condition we use filter()\r\n    - filter should happen based on certain condition\r\n\r\n\r\n -Stream API allows to perform aggregate operations on collection of data using filtering, mapping, sorting etc\r\n\r\n  There are two types of Operations perform in stream api as\r\n\r\n      - Intermediate operations  : The operations which are used to transform or filter the stream of data is\r\n                                    known as Intermediate operations\r\n                                    map(), filter(), sorted(), distinct() etc\r\n\r\n      - Terminal Operations  : The operations which are used at the end of stream pipeline is called Terminal Operations.\r\n                                forEach(), collect(), reduce(), count() etc\r\n\r\n      - Parallel Streams: The Stream API supports parallel execution of stream operations,\r\n                          allowing for efficient processing of large datasets across multiple threads.\r\n\r\n  # Parallel Stream in java\r\n   - Java parallel stream is one of the feature in java 8 which is used for utilizing multiple cores of processors\r\n   - Normally any java code has one stream of progressing, where it is executed sequentially. Whereas by\r\n     using parallel stream we can divide the code into multiple stream that are executed in parallel on separate\r\n     cores and the final result is the combination of the individual outcomes.\r\n   - The order of execution in parallel stream is not in our control.\r\n\r\n   -Parallel streams are introduce in java 8 as part a part of stream api\r\n    Parallel streams help in executing collections parallelly by utilising multi core processors and improving the performance\r\n    By default streams are sequential in nature and are made parallel by invoking the parallel() method on the existing\r\n    sequential stream or by invoking parallel() stream method from the scratch.\r\n    Parallel stream divide the data into multiple sub streams executes them in parallel using multiple threads from the fork join pool and combine the result\r\n    Parallel stream are helpful only when operations are independent of each other and can be executed parallelly\r\n\r\n\r\n\r\n  # Advantages of Stream API\r\n\r\n  - Stream API allow us complex data manipulation in concise and readable way.\r\n  - Stream API used lazy evaluation meaning only process elements when needed.\r\n\r\n\r\n  # Stream API and IO Stream are two different things\r\n  - IO stream it is sequence of data using which we can read and write data\r\n  - Stream of API is for processing the group of objects or collection of data\r\n\r\n\r\n\r\n# How to Create stream Object in java\r\n\r\n  There are total 5 ways to create Stream object in java\r\n\r\n  1) To create empty stream\r\n     Stream<Object> emptyStream = Stream.empty();\r\n\r\n  2)     2nd Method using array\r\n         String[] names = {\"Uttam\", \"Aniket\",\"Divya\"};\r\n         Stream<String> stream1 = Stream.of(names);\r\n         stream1.forEach(e->{\r\n             System.out.println(e);\r\n         });\r\n\r\n3)        3rd method using Builder pattern\r\n          Stream<Object> streamBuilder = Stream.builder().build();\r\n\r\n\r\n4)        4th Method using Arrays  (anonymous array)\r\n          IntStream stream = Arrays.stream(new int[]{2,4,65,3,5});\r\n          stream.forEach(e->{\r\n              System.out.print(e+\",\");\r\n          });\r\n\r\n\r\n5)        Using collection Object List/set/Map\r\n\r\n          List<Integer> list1 = new ArrayList<>();\r\n          list1.stream().forEach(e->{\r\n              System.out.println(e);\r\n          });\r\n\r\n\r\n# Methods in Stream API\r\n\r\n1) filter() method\r\n   -filter method takes predicate\r\n   -It is used to filter the data\r\n\r\n2) map() method\r\n  -map method is used to perform operation on each element\r\n  -map method is used for transforming the data\r\n  - Example: Square each element in list\r\n  - map() method will modify existing stream\r\n\r\n3) collect() method\r\n  - It collect the stream of elements\r\n\r\n4) forEach() method\r\n   - It is used to iterate over stream and takes consumer interface.\r\n\r\n5) sorted() method\r\n   -It will sort the stream\r\n\r\n6) min() method\r\n\r\n7) max() method\r\n\r\n8) mapToint()\r\n\r\n9) reduce()\r\n  -Many times we need to perform certain operations where stream of data get reduced to single resultant value\r\n   For example : Maximum, minimum, sum,product\r\n  -Reducing a data is repeated process of combining all elements.\r\n  -Reduce() method is used for aggregating the data.\r\n\r\n\r\n  # map() and reduce() example\r\n\r\n  -map() is used for transforming the data\r\n\r\n  -reduce() is used for aggregating the data.\r\n\r\n  ( combining elements of stream and produces a single value )\r\n\r\n  Stream: [1,2,3,4] Calculate the sum of numbers present in stream\r\n\r\n  Map() -> Transform Stream<Integer> to Stream of int\r\n\r\n  Reduce() -> combine stream of int and produce the sum result\r\n\r\n # reduce() method\r\n\r\n  reduce(T identity, BinaryOperator<T> accumulator);\r\n\r\n  identity is initial value of type T\r\n  accumulator is a function for combining two values\r\n\r\n  Integer sumResult = Stream.of(1,2,3,4).reduce(0,(a,b) -> a+b);\r\n\r\n  identity: 0 which is nothing initial value\r\n\r\n  accumulator : (a,b)-> a+b function\r\n\r\n* While using reduce() method with list of String we don't need to pass identity\r\n  instead we have to pass function expression\r\n\r\n\r\n\r\n\r\n----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\r\n\r\n# IntStream and Stream API in java\r\n\r\n           IntStream                                                                         Stream<Integer>\r\n\r\n    -IntStream is stream of primitive int values (Data types)                       - Stream<Integer> is stream of Integer objects (Wrapper class)\r\n    -IntStream has built-in concept of range() and sum(),average() etc              - To do sum operation here we have to use reduce() method\r\n    -IntStream is a specialized stream for working with primitive int values.       - Stream<Integer> is a stream of Integer objects (the wrapper class for the primitive int).\r\n    - It provides methods specifically designed for numerical operations\r\n\r\n\r\n----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\r\n----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\r\n\r\n\r\n\r\n----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\r\n----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\r\n\r\n# Advanced for loop in java\r\n\r\n   The loop syntax:\r\n\r\n   In Java, the syntax for a Advanced for loop is\r\n\r\n   for (DataType variable : collection){\r\n\r\n       //Code Block\r\n\r\n   }\r\n\r\n\r\n----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\r\n----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\r\n\r\n# Optional Class in Java 8\r\n\r\n - Optional is used to avoid nullPointerException\r\n - To handle null checks optional class is used\r\n - Optional can represent both value and null value also\r\n\r\n Usages :\r\n   - While creating  method which is called by another method(In case of return value)\r\n\r\n\r\n\r\n\r\n----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\r\n----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\r\n\r\n\r\n\r\n\r\n\r\n ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\r\n ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\r\n\r\n# Design Pattern in java\r\n\r\n - Design pattern are the well proved solutions of commonly occurring problem in software design.\r\n - Design pattern is the way to handle commonly occurring problem while creating software.\r\n - Design pattern represent idea.\r\n -\r\n   Three main categories in design pattern is :\r\n\r\n   1) Creational Design pattern\r\n   2) Structural Design pattern\r\n   3) Behavioral Design pattern\r\n\r\n----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\r\n----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\r\n\r\n  # Singleton class in java\r\n\r\n  A singleton class in Java is a class that can have only one object at a time.\r\n  It is one of the five Creational Design patterns in Java which helps in effortless development of Java programs.\r\n\r\n  Here are the steps on how to create a singleton class in Java:\r\n\r\n  -Make the constructor private. This will prevent the class from being instantiated directly.\r\n\r\n  -Create a private static variable of the class type. This will store the single instance of the class.\r\n\r\n  -Create a public static method that returns the instance of the class.\r\n    This method will check if the\r\n    instance has already been created. If it has not, it will create it and store it in the private static variable.\r\n   -If it has already been created, it will simply return the existing instance.\r\n\r\n----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\r\n\r\n- Singleton basically only one, this means we can create only one instance of the class\r\n\r\n- Step 1 : We have to create a static instance of the class\r\n\r\n- Step 2 : Define private constructor\r\n\r\n- Step 3 : Create public static method which will return the instance of the class ex: public static getInstance(); method\r\n           method should have object of class\r\n\r\n1) First create a static instance\r\n2) Create a private constructor of class\r\n3) Create public static method which return the object of class\r\n\r\n\r\n# Types of Singleton class in java\r\n\r\n1) Eager Initialization                  : For simple scenarios where the instance is always needed.\r\n\r\n2) Thread-safe Lazy Initialization       : For multi-threaded environments where resource efficiency is important.\r\n\r\n3) Initialization-on-demand holder idiom : For a balance between simplicity and thread safety.\r\n\r\n4) Enum Singleton                        : For the most robust and concise implementation, especially in concurrent environments.\r\n\r\n----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\r\n----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\r\n\r\n # SOLID Principle\r\n\r\n  - SOLID principles revolutionize the world of Object oriented programming.\r\n    When this solid principles combine together it will generate more maintainable and understandable and flexible application.\r\n\r\n   # Advantages of SOLID principles\r\n\r\n   1) Easy to maintain\r\n   2) Easy to understand\r\n   3) It avoids duplicate code\r\n   4) It maintain structure\r\n   5) Flexible structure\r\n   6) Reduce complexity\r\n\r\n\r\n  S - Single Responsibility Principle\r\n  O - Open/Close Principle\r\n  L - Liskov Substitution Principle\r\n  I - Interface Segmented Principle\r\n  D - Dependency Inversion Principle.\r\n\r\n  S- Single Responsibility principle states that the class should have only one reason to change\r\n     or it has only one responsibility\r\n\r\n  O- Open/Closed Principle states that class should be open for extension but close for modification\r\n\r\n  L- Liskov substitution principal states that Objects in program should be replaceable with instances of its\r\n     subtypes/subclasses without altering the program\r\n\r\n  I- Interface Segregation principle : Segerate interfaces into sub classes instead of one concerate implementation\r\n\r\n  D- Dependency Inversion Principle :\r\n\r\n--------------------------------------------------------------------------------------------------------------------------------------------\r\n\r\n\r\n\r\n\r\n\r\n----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\r\n----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\r\n\r\n# Garbage Collector In Java\r\n\r\n  # Garbage collection in java is automatic process of managing memory, by removing unused objects.\r\n   -This overcome the task of manual memory management task\r\n\r\nWe have two types of memory space in java as  1) Heap Memory and 2) Stack memory\r\n\r\n- Heap memory will store actual object\r\n- Stack memory will store reference of object\r\n\r\n- Garbage collector does automatic memory management\r\n- Garbage collector is used to delete the unreferenced objects from the heap area\r\n- JVM control when to run garbage collector\r\n- System.gc() will run the garbage collector\r\n\r\n\r\n # Strong reference and weak reference and Soft reference in Stack memory\r\n\r\n#Example :\r\n WeakReference<Person> pobj = new WeakReference();\r\n\r\n 1) Strong reference :   Object never get deleted until strong reference is present\r\n\r\n 2) Weak reference   :   As soon as garbage collector get run this object will deleted\r\n\r\n 3) Soft reference   :   Depend up on gc , but only do if there is shortage of space\r\n\r\n\r\n- In heap area whenever the object reference is not present, heap will allow to fee up the memory using garbage collector\r\n\r\n\r\n\r\n-- Heap Memory in java\r\n\r\n- In Java,Heap memory is divided into different generations for efficient garbage collection\r\n\r\n  1) Young generation  (Minor Garbage collector)\r\n  2) Old generation    (Major Garbage Collector)\r\n\r\n  - The separation of memory into the young and old generation allows garbage collector to optimize its collection\r\n    strategies based on different lifetime of objects\r\n\r\n      Young Generation :\r\n    - Short-lived objects tend to be collected more frequently in the young generation area\r\n\r\n      Old Generation\r\n    - Long-lived objects are stored in old generation area.\r\n    - Objects that survive multiple garbage collections in the young generation are promoted to the old generation.\r\n\r\n  3) Meta Space   (Outside of heap)\r\n\r\n\r\n\r\n  1) Young generation is divided into 3 parts\r\n     i)  Eden\r\n     ii) Survivor Space (SO)\r\n     iii)Survivor Space 1 (S01)\r\n\r\n\r\n   When we create new object it will goes to Eden space of young generation\r\n\r\n   Example:  Object1, Object2, Object3, Object4, Object5.\r\n\r\n   Now, suppose after periodic time Garbage collector get invoked by JVM\r\n   and in Eden space Object1 and Object2 don't have reference\r\n\r\n   So, Object1 and Object2 are marked to be deleted by GC from the memory\r\n   and it will sweep this remaining/surviving objects survive memory space\r\n   and the age will added to survival objects and this is called young garbage collector\r\n\r\n\r\n   1) First time garbage collector runs\r\n\r\n   2) Second time garbage collector runs\r\n\r\n   3) Third time garbage collector runs\r\n\r\n\r\n   - After age limit object has to do promotion\r\n   - Promotion means moving object from young generation to old generation\r\n\r\n   # Meta Space (Permanent generation in old java and is part of Heap memory)\r\n   - Meta space is outside of Heap area\r\n   - Meta space will store class variables. class meta-data, constants\r\n\r\n\r\n   # Garbage Collector Algorithm\r\n   - Garbage collector uses Mark and sweep algorithm\r\n   - Garbage collector uses Mark and sweep with Compact\r\n          -This will compact object/survival objects in sequential manner\r\n\r\n   # Different version of Gc\r\n\r\n   1) Serial Gc : Only one thread is used so work will be slow and Gc will be expensive as all application will stop/pause\r\n                 -If Gc is slow then your application would become slow\r\n\r\n   2) Parallel Gc (Default GC) : It depend up on core so 2 core have 2 threads, 4 core have 4 thread and it is little bit faster\r\n                                 - Currently java 8 using parallel gc\r\n\r\n   3) Concurrent mark and sweep : While application thread are working concurrently Garbage collector threads are also working\r\n                                 - Application threads are not stopping because of Gc thread (Not garenty)\r\n\r\n   4) G1 Garbage Collector : It will garranty that application thread will not stop because of Gc\r\n\r\n\r\n\r\n----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\r\n----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\r\n\r\n\r\n\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Java Theory/Java Notes b/Java Theory/Java Notes
--- a/Java Theory/Java Notes	(revision 7666dc27f6e206e4e9b2d52f3391b893744e1464)
+++ b/Java Theory/Java Notes	(date 1748932778074)
@@ -103,7 +103,22 @@
 
 ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
+Static methods:
+-  Static methods are associated with class itself, not with any specific object itself.
+-  They are invoked/called using class name followed by method name.
+   ClassName.methodName()
+-  They are called using without creating instance/object of the class.
+-   Access only static members:
+    They can only access static variables and other static methods of the class directly. They cannot directly access instance variables or instance methods.
 
+
+Instance Methods:
+-  Instance methods associated with specific instance/object of the class.
+-  Instance methods called/invoked using object reference followed by method name.
+   objectName.methodName()
+-  Instance methods can access both instance variables and static variables of the class.
+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 
 # Different Types of Variables in Java
 
Index: Java Theory/Images/Abstract class and Interface in java.webp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Java Theory/Images/Abstract class and Interface in java.webp b/Java Theory/Images/Abstract class and Interface in java.webp
deleted file mode 100644
--- a/Java Theory/Images/Abstract class and Interface in java.webp	(revision 7666dc27f6e206e4e9b2d52f3391b893744e1464)
+++ /dev/null	(revision 7666dc27f6e206e4e9b2d52f3391b893744e1464)
@@ -1,319 +0,0 @@
-RIFF4  WEBPVP8X
-        VP8 T  *>m4G#"!4
-gn4;~ n=!n3=~/C?
-o&_P_5
-gSU?xsW$xK_'_?mGci7qG?`?be3~iG_/s?Vz__W_??m )}__#gs?@AY}s/'$R?jR|C3Zbc9/4xw';=9CAYp:"U,*w0adaB8Y<<<6a?f$X5mpfB`_NWv}8g_ocHoc!f4Kn<>nOr`Ar+t2b368ay.#:d;z`_.V{OO4H+`o(aN@fPVm[9*`ZC|U;p=P'5D [fNg*!\]P=T?c+92
-PoRizE.Nc7IR	Xx
-}x-DP
-Rfxj`TMC;1'
- Ps/a4	PIC@<50*&m@J,*Br3.uOfybrI 'tPO: Nqp(gI{.;n)C?L ?0`bB
-yD2,*|hQu#LwCROy9<uLg{ MGwWC34K9E!R>B lc0r}mzH@`G
-Bzb ;{wDb!KJDyZ@j!jV`2Bs6,eO8'{b Wu}-UWON:{0fv>k<zP\#:/OG[
-U4hs7j'#bCVy>KX!j4
-psyr5(=(4|,),Xo\99p3X<sZvZJo?nV5Ta6|N!_G /5;0^>@QpTXtM xx xt!9"Y^KL-pSuB-H=0%
-HD^%zsheW+|:uKng$ .bo.AVPB-FIZ$5fI \73B>8YNg3sc*bz7@9se<>$7qaT@Z5z>tU$BN_2
-kr
-,VyG#"PIvdYbS2W:H&7jH$(#xK?gG<cp@57WA$fyElCaBJJn]H;eI[AvhKS`E7$`~6IB]
-+^Q
-8 %	1aE]&,{Ow=kT)nAq S/a5?4LiU^D&\jZE$$Ch;NK P~m$t	(/QHs[y&gXo"3.nOIa4XR 
-W[i7qXW_6VDLpGy;NR";vEtl<	s98198$%Q.hP|CBy%wR?Xfd#N|gQ]`d~T`$(S,~]@l-u$JD+@Rmhc=m)6GI,7*U WAHu$S81G^${qEo
- V
-PF6:jHF#>A\Ge n=D;Xg9kKgdeReEl3m!ExsT!]6L1#p<8V/'A{Dsl;Fy@O7&@LG#	n;*&?8!	WCG/Tct{Yg
-CQ[QEHbF_?~^8-=MP
-BHg+xV1)GGQ2__kWG9 |f":>-%U9<{9T,r0i'\5q`{7//2:5;xA5QvVoXm-$ib:SKkrl>q^NzOps{S7\ds:K22,(F@&-?Zx7ip-XP}_48&s%r 7B9\8/FKRz2yAGk:J)!}LW<>@&HwgY,#m}~+2;Na9b+c}tpiOi'k#`roAOOki)V(xrn0\rt.VwG/eWkvBV}J I=k{fVov4_$J_jN?y5VBxxS5_fgB|+>%nx4Tvi  4qZcm<-s/y2GmbBUG1Cu*y*HB8=GYqq U`}]3=. EGAxJH2htQl h @ v b1\Lor!poDL|vtw65~R(L5h,5Yf'(_C%>YQf_R[S]
-1M%fe^F.X]`y{?:mYhj	k|F+k[R
-gr<l<zi5GU_
-{ Ty
-^_rY%!1
-];9h 
-7w+|Py~@5}(X,wIgG1,Kw8@pC2z  2!K~t?[BX~[g~ja79Q-;T::T$:Y:j2
-+0f^<?*/lK wzP>gv $``kF!+7fD9pKO
-@?@ L1Bgr)OIx=0C9~M/RxyF7[X/PcA;If7<J|7mEN"Fn_bnR^VPCls Z_5ie Z}&)|PuOU[OxOF@s]S3}=7h'";@SF0qTSjI\Qm
-.mW'LRc\)\p>?0IGGCOV$ u{"&;B%n^b##z9^\4^O5Q]f"JFU[Z !V=nER'oA2=RUr :d3
-( 9P6{w="H{rzw	/
-Iu6de-m;'E&4/-:#=3^C
-u/-"K|c-8}7FxL2zTwFfw6}aZ5Aj]-Dig^="@BX!G;cv<)`>U.57N|#^1AkC(;oA~-
-Km	G1}n&	Nj31u@(Q-,;]F ~W]=/'0me7mrE;Hxb)9Ih16+y9O=Kq~eHgAUrz
-X3V~eM%/jT1c/}D?]Bo\jdB7I#dT|D;Ky cRMJ6"#tT@"/TMo
-u5RN8IA+
-&
-iVmk5o0puh*33jh4S4"h8[5E58$
-~F2-W)5+kP}GyC.W`Vii+(!!86+ill\~1qDmon6\Lr5!f-4e;N%dG2_?Z%|o69xZ|AmKsFe09 bdW"SBB\k*A4tg%Cfi.d$g0T r
-,Y5h%5RLCqVp	?.4oA!eX4'Iu"K|ajO6!#K8qs>s42JA_/]U629g\1[
-+g`4'8_/}GQq2^igxXG~5lc]"Q>7xJRE\g2w+iK[_qKVC:?;y$fI"Qf:b"%/F~JO,~l(32tNQp2AOU}%L$n`jW*=2'%>I~W4{x	Ou? 	q1 hv	%y+`	Xs:N\{s Zw!6yoG
-KV\09zq&RfFpG8{K
-afyZ]Rm@BT*Mo@ o!b 8sf.bUzY 4IQww
-qO(~>#8lI@o4CH~K?n~RiW;vT4)$s-AcPr~i{a';sw$u*iP)mF49Pk;BrOuh0	 W\.MabvAT2'e\e-_#1R&;TKglC^{zb%fw
- N}Unj =K1"~bE<O?"^G2]N 2K0`j4&Ax{45lT;u1FZ`v&/lmNvC1pGl877DMr#[^-w\pJ9S|_&	^pZCIp mLA+YF$(vx
-rd(~c4xe!mR`^vXa-EO7ZRW^E:I` Qm$c;{=>* Ta4S<z] U73G4?sYPr&z9]i<[CL4[\7fTZ`	X4X-^	@{NWTp!=+(w97NHDOEC6""'h/)R8BP+~e"Hat4M*J%Tr~s<3Xp4^Q{c<C^V()h;_v4i(n"y81%yw>\ia."[#a0j gSCi-ztO[^q_I_([V}Se#%\Y_;)y-@1BU}[7u}&PUeGQ1<|Dp4n>@nLtR(eKPp
-1I$:fxfGFN ;,jrOyX&2	'JB4uMFnr}>J}A:4)mj]{peF:L57>!BNLInt(75
-XSg.v[[P!	b(YM0U{[_Z3&1g1 2nyVmdpij6L=1d
->8)r]}{AgW`h]h)d,rF Iq|]KjP"x+2}obX2oJNAxZIL*_
-e1NxjnuK9t~l$bE/!PG)qQi
-G*..ybcmtm(Ehk*x${6l5vMu[U*lN_##6E</ 0A#XNO/WR B;2SU|D(i'.5Hlx ^Q /D9}HHPv
-	|qY<#IAp]x=j$+:UgKr8F?ONXPy-?k u2aXT7v]nVcwfFbv~=ez[tEUMAOIjT|z:M6$5`>_eiJ+W5
-N 'P?3!}8Fpn">H}J\;.JL\s|Dj6xL~:R?qj w:gA	k"J2 IZwD\;U`H)H\7,l+(E1d7-*|LC1=0IQ5Foz$f 4MJF>[bT,5d:A7F&#u/5l;Bv9glJ4#8D$;"qM7s,U[v>=<K]i1/9s+wiV(4*3++5G[ZdKU\y5P)~5l"
-	co"[A`s#kDP3S:o	<k	Z^;88lZ
-GGw30n.
-1iey*
-\@IZ$}NFqv>'Z4*'vOApY5
-bJ0/TP%N[
-<X
-YJC"[Lq1=)5sG{
-i':;^2u4
-E.1E8z)!mJ|'P46TcET{E'Rd/VA:
-mU;
-69M<C)j{Q3U_I/xt7>~@ BfDIQg3`pAQduDIFP]!jmfR*KXEkfVs#li>p4Lb@\YZ6Tb~Z,Zk	%[yq^*Iz*M.]'OMrW>z|-0VDN`l7<XWucK-up,	=k !s3OM=.NCvcL4;@4|-=pd*Ql2"m9wzx7K@(UWot/U	t`]q^N2"uU{>t:2| .{z8@H%|/\k(}$	E$xbRJ , D  0b3qlL~R>@>Vzt'py6%9<x'uA\ w}z"8,5I9017{`|z?<YdZRM6$H0GRn _PFt }~It/	5pT)R[HGQApK ZcJp"w&WOn@6c*b5T
-*1zZw:|9~]h|2AW-.hF#i(AX\mlb`/D/_7ZLD.Xs}f0#Dfs;Y ?w3}S-`=y]:~(&my%qQ_"SmZK3_Vy,j|.T 	Ng
-lZ0pi\G}bY/=W6L}dOUt{(TUK
- h*vQJ\kgBY%?o
-LKLT/ kedc]6XI7F 1-b/5HN5(ycKHhH(/mxWXEA~xSO/.m Y#@3\ P`R):;(_PR#82` ^
-WGH`9!l$sMTPr:HLs:Z3-O']DtKYI-qO|:nxw"1$/Z2>g FKT}5[w|d`~l>cpyoKMIoyo5*3X
-3Y:c'|%)`jGy tk|wCd@(7o"&i .ZC6l ~ 
-;3'^MyiUR{yxXc\1+|aSTR&ZFVI%% X^%pRG(Bj &$rWgKSWr=+G!+{PB [gNJ-@t^^3dmJrW74
-,'(}7|o@nO?~v~`H<4 
-65p,G.#?3Q90)e<.BU{BN<	uMGB>k!	tAotzIWx%aR- ]+b[@R`6
-[{km*Tg
-P?LhdH.IdG gR-wYU7 s;<,e=:]bz0e0
-/RPeIk5|vI8/*$fiE\%7r-/?5#/A5L6{/x=~b T
-, Ns(~!-EZt[VEZfJiA5=)u<E\MCx#
-K~l 7Q?!rGe\H+'[C7
-7lJ`A}iei*mU_H',Hol[) hh)b=q/U!cZcqz
-b dNOzOf@GJWAz@*X @f:UP=T):X d[oXj>njb&::67piFt
->%<yI?FL(+>R`6W]'.PA 0DNm(Jt0MJ_4'=.\pP	<<e}}x<:rtr`bhb1l$
-U>pAXB GUcm2Y0]HC#O^tm?>>i<5]	~rz#p_)=F^vCU#6AZ;N]p_yt0#KKJA3	4_p+>tzH}4c_H_bI".'"|,|79~rl0I{/{4xtgR^ty|L
-sCz?8
-4Gh40~JB|DsD!gX`i&P^0V0 4/>Q "''8)BJEjh}%~>x; qc93$Lzg/4k/Q <QLO)d~092y&eTHU&2J9:3!,I
-T(J
-M'\THgc)?{6Rt=fPy6t!n<E4U[ffd*=VIhd$aGV'F/3'<0/HS'3
-4t?ODR4X :8eS*}_>X-^H=xM8Fz#mhL=2pygON+F+%LNNL9n&{ !r|"t&I})tknr%4X:gmjY(XA
-bmU6A4$4
-OPHWuG)7v!4Sov!a9b)x0QDKa5TG?B3e'y]cAUPaCcx:7H8IL'wP\KS$G&HTCI'4~Z&G$6^'9b g1cmhvj|O'A 
-d~{I2UJCl;	S8?$hb.	U<KA;
-nwGiqG-W]@zaAEIO[O8[)cySm#{65yUZUq_2?C	 j#(55A-b[w1G+cgRbpgMp	C~-2=`Q
-\m#}v,uE%1o.dy>un9;7uIRbl:UEVk3(bnFS!bVfzgo[qLI<R,Jy{Z7u{ sO}FXdwPvvu_`W  v@Yst3 AVDKDYTp8z5tCQd59(2A*(gI|@S?YVpN}Z] !]	pt )#.ezLd3n[1M^[	<UXQ(
-g/gl9 2D}FL.I?dU3`Q"H`3PnFW%*D@Ym[}v@wsoB
-~)#26}4]:W>^s?!.~c+IB5	t`2Z q?fok)e}q	7GjvZe gnPt!LJ%OR=ii0vJ_Ll%G(V [x\OnC8VFW	
-~!l^*y8,8y}!Q~&FkI7:T]V~3|v&M	c'TJ$l^.]wBmM]cf)2{4S}BfY@yg"i 6&	P{ {N7KU:&Y=DfOk:J!pgVb02z3q'`dRws	"UgF)nNgskTd".zO%??~N(dmx[)8jUa<}%^CkASb-]c;"aBZ ,{?OjJ#I}/F~$nlj:^UCw38X\-7.yOs|1.q,&1V
-~qZ|OC[M4	]RWf3xL U~WL"AYbGNE`ge o@   c.P ZDM&-2h n}	tGzv]52yU|:<e:3P1N	q`?/xo 
-?{C kj]~P\UStBxM7 M0~I
-L[KL)xE4S2,As\C&`xLf_>{	'w,[W91) +j^=W?H`4
-)[36lOAs9%?~s'!%;r-q%p?ClS{Jy"qpF!}dXwb)=U
-~K_j+%&AE7vcH2\Grwbt|Dj_VZRalb:c=rP&8
-tGj"z
-5yn
-S4s[~/n!}fCd)fP#yT/*$rOC;aKm\;+oX&-p0o^yHF)GRoi $h $.Rg
-A5k V $w+QSkc},4h,0,	"U]f({%#GHx:jp )g6}` ZR?1DoF5YH	BN4:n.uW~]lCya?PFt&gt00>fe/#;,C<[Pd} 3?!9	z,#.m]5P JyR?H2We*OW[}h?7g0nG7
-bId3ze,qEw
-YxS4NL'3S91guL.O
->tojtwv"QGl+wy*O1?{Wl$quf]0Mg1E; LPE0g2Ryjs9/}Uf<[| (4-^qHKT& hH\e~`N-@}*4_ &[@YBO-YkZq6>$*\LWUWv>k^lk0Cf\m Bc`zexcj@-
-6!G31W~vzds%!l)Hd0Uh!@"0	h3~j(vvd=)5T~E:#_]%aQgkj^)m=w(ZU	Jau}s(Mu9
-)\~!v&@
-Xwk4!y
-q6TPo<:v7H)1xi/VKf=! x4kzwj"P6,9Sx}zqR`)#@n~I"Lo]/iX#ZO
-E_	k[pz9G
-d1#@GibH&SCOG.o4+n^J.bW[a\z9W%p`"{K4\!g: [;K`3=mPE
-6M}H8l|);	
-#exWN1vmSy7tR`C2PY
- Gs',{o"Uir3]H,5L>BMMKiBf.metM`RRhZyZC(b6VffV|54zJ~DV=.(*W^mCssr'Ax{(5)r
-e5xmk|'j|B!D823J=60 ~}q;8H<^D+D 7..ZK,rJ^7pZ.`u\mYF x^u2kxABkuEL\1u*P/)3?u.z|jx|.OO4)gQ(XE4lp|%D|tdrg(ph+v*ID.SG(Mk1	\
-]!voEF\|alWz>7Qw-3(?1V@
-fXR{ByvD_'Z#PmuJy{z{(8h\>yh]^b?My).o(W^^<zq`n:RerQ:A* 0l*_2S`MlZp
-a2x8@R.dTy*3lT&^
-O-dy`1"l
-n)Tu@#uo_b 3ir$dZ>Mtxm9mAs>>GW>:HT<y0 Q{BwQtD|2^eo
-
-nib H-y[~r\kLnh5 SAxET?hM#:Z$SR;E$99YH/vg3X|NC7,Xl<mPQN ~kY;?%x3*M<{c	D V00]wnE|<`^F<'|!f-.}%DL}4S0*]L
-(*cI6V0PW>>-YswY3\2*Cn@P.fN&RKw"sB}(uQlz.^(WjsX0gs
-V?B'"YK  ZP`(Of
-\ 3GOT[?g	b
-QTK\D\fApHApKKWv40a4xOOUNLXxA:u1BYH`.-|Z(`}, vYDvb%7#6d^t xDn:~nc5kA/<9-gq5_%`DzSZ2k)	d
-G9(M~EFm)'&l+utd72{JdIW^.I9EZp 9o 7FXAg'IMn&36d3tGT!VCF/: '#ZNM9'lltqao{zR[
-` R-cGr#Kfyl52UE^Yo]8w\0Cxk#L
-yh5V~yJ;J>!xDij)ztlm##z`{A<cg09[X,i;sflFd^:} 5B~/&_.oB@,|@@F0,?@Zi!H3-UX
-]LR}_I/5&{</-O2ORL51YH>B6@5|C $63Mk	v54o_	VFZQ!';m9.252}Ig5{,t^]Q,nDod&mz9fyJ ~.Y4By~T?Q8%j7^6?>V
-u1ef~9^WdCgr"CBYv$H[SvmfJ
-+2\0L<;du`KWB*)l}LZ;?KMF8=.66shKg>@;	z|dL/v'(Q! iL$mu6AWzV.+Gv&n><+YnH{EGT@m,jDV;NT
-Cu/#<u[)&:!?@uG#GRF#zHcRN,KM|nEa4s0(=j|L#7#3Z$V	rel6/Bmfp$iMC`%nr*@a =i %Rs^}#?M[)SZkl2v
-hC}}tm+xO
-#fvZ0>CsUw||aT pt&8ku2c1vkQ'` c%|A;~h'VnB_ s@%te?An78pVFTL <4|K$oDiv
-$J 0DXTSp]l^IQf,`V9o& O#8 cFwo?n=[%" j>'q7b'CLz08F	Qau+7`94}=L2Ps<H@_GJ9k{HS
-+gm8<S\'Pc2<9@^u{?MWlV:xxE!&i1hI 2R
-pS7cqrCjfBMXJbF1,lcl>YLgOP$+*]YQ[ZP"@3f[2RcM&_F4 <]nOm;=4kg&=.sN|~
-F+`J()
-xbxR&'KfX%$jc5a[J*"|qEV-3XB+FMQa	`\o#^dRX74Im@lM}/(
-EZ&xR#{;-	p	7UE.anX,*Kp.DJ?S34ZRqD-(5zFDvg	m1boC<^rLbYLEt%?Uye/0
-)Ew	\m)=qwAvJu\I}{:
-uX^m"xQ}~6(}l?kP|mMB{^!&80Do-Ds`YiW#vE"bVn]oTxi	P[R
-oRG"|fThBz'n.pvs Ze*D<1l)0HAK 2+#7:	$}68o.%={piq BqJ9|fb.kq5NdY#-I3vb|mhC31=Ig:mGNu ^	,BT
-;
-c,i #0
-;NL@F&5o R\@8X1CR*%Wt}?SId];Z%`G1{{k0~21_\H)Ev
-Wlexd~1 eg`_
-*LT!{scxH_6 I8E5R
-5e37reLumo1&@+F#qs@-A7-e	Y#HpMD3J
-l"1`B wk z?eT
-p~MPY	u!0G<[LK,g30,n$ GlFX Zq4`A+(l2U01^C*-Rp-_L/j<?6MXQ(z>0GZ6eVfL@y|9VQ)itfkw1;9W;@7QRR$u)FQz2s#@e|mD
-7O<JTP$B>vOa+U{zZ%W~L
->	krat.9,5koKh#-3/=$[E,&KAdh]Ts
-H:Pxdy$vdW{7mSRT2<krJ{8e`ota
-Hdqc!f!5H,p{ u7M=`m=$9+yzJ%clRz&Fd9$6(e 14z)3,#cHx}"zCePX3vE<'r]a<o,F{uOLYOUv8kB!qfmhaP\s)y>$9qA /3k>RX{u!3w#w)=Ap+? 4 :%KLPFE*'%~.=44	[wa~B2]4:
-S+GQ8-0!Gt
-$	:2h';M$B$v*7gRw5+z4G`$6V.e?5"4Nom~~`ML+<pD!d1@:lr+re{_5[ JmM^ETT;kAau,sd>}(@"`O=G>`f,&JH $]t4*={bG?^rn>k>W~>,yD)#EWHlBg;Gg+ 
-~ T~\*x8;Pr
-zi@jv.LMeX[+63j9%@qQg >fS&vFIMYIz%.Ki'I)4ESy?Zw^iMou5n{3}LKYi&YDOK3N)6s|Vn4wJm?\$u4^3^5
-7tu	(tyEhnS
-`)- b1;Qn77jnS4V`"bPC|[.|wJ^
-KS:W_1{|eLNrpT[nF~(a^b6WEeek`6Flr}:UMU wOI.Y8;LX:IFT@\CJ Fw3`\O
-Ye\ e\c_-Ou
-!zr{MU$td[D >7QBW:W@EBv\Cznx1
-%'lfTw[iP~`Ez&N=$.G}4
-/~z	Y)>Imea9us ~v,NJ?	tKv3xP
-hR~s#x^-D+5M8<s=]a [b)"HM6QcYjc'X#}mcp^}/ODV0A9
-.]ijA%rh#a]NFO{]-03+Z"&_#2KP0H#n.:Y( c`dYb"8R
-_BlV
-<WfN 88J@%Ei~k<Fx!{5bZN	>$2-7x;Wp<jfo=]Fjc	z)Z 4hN+^v}l Us7#orCp   "H}W5h(^CE?V.7/ta$pvjP'Iz*CrD69Nl`PA 7@Z0#U#l?BtlU,yqKH>w
-Gu #zpD?v$1|v]IR0X1cy|E"*F )||SiW	)Y=L\OPi"w^o7*bt|99B)eI9
-d +~?aOqh"N6M^)ShlZR~dKKQNd3;	
-;4gZ\]xp QM!$n?<\I<J?;IV+5Nr&  rVlf1k$^x]7k,'\w q>&F}ZqZ#^5#6qWT5%]-Bj\P=5O! Ji W
- 8|6XF]lKcMd"T>a:Z|h is$u#J-!
-d!aunTD
-Br5FX6LbsU6NMWsOv2	8y;
-hyY.s&/}Q{k6f,YMVDm&hS9 Q][u
-XR	V
-u0 H P_ ag.6&K'`ht:6-I	@<IF2A}7_
-DF~d!m]JZ-6tT+ *y8>^Z
-W/|UzsmpU:<?-Wj[X:^8""/Ns`o\@aGn<:d]19
- UCM}#+bp-]~fmLGLao<q4i
-1e]$-8K97 |:m8JZymQoqz[+i@]oWsT|Z}_3Q~'`Fa	^8*n{v@)#h<Z_P*r.pb qo}go#yaF8118(!EA`3b3T_#ZKy* 357dI\{ao1R,=PHCx\ZU=:UEFN[53W/`no`4{Fe@!H"Bh<_)U2 k\o0+/8jt2aRjW.?[MOp6jAh3.EoV84h.Si\_iQ: b9Z//l{vdf[+D@C=--!
-JPI0+?Ubmf=$.Tj{e; 31qcyb(-tqHKEi]6
-O0-y;JP,	W5CR2&U .w@ !'{+Eq4AUz66 ;6-{R[Y-ywM2cACS!aPUAVOK)$U*6}19&DF]B+zJ2heYpWnj.=6pmdqhw\'~k9aZQ,.w.Ss>lbP\x3|?%5Q7[VmQD-dVc3+g;HHxV>6HY9Nl#ix*L)NQp>s(dn+=_{;y6F|W ;613`V~d#7~l0eoA4fAo%dd)96D^@ohK(&y'+<]R]g>qhA{>?Nz+G
-`pOtm76'.U]I8+Ln;|;@edc_CDcW(	B Q-8U!]~-f?JQ)_cOX+U .a_y@8?(^U#H|FgMiW4pc;X{<L5eN[	vC,o#JVQ_D9^j#QI25)F4U1d?*1\	30aNp0;k-wD;+\OrcusGAmG#>YH]GH!mj$W#}|F0	m=
-lIWX~o>a}gc zMiKB4aL5wI(0O=o%r=.x#y{=>m>pV~t%g2zl"|LO/GC)6W[aJ"#	'H~1SU 7[ Pl9Ml7|#s5\p94N1mo+{KJ'0Tu [4XT[wW$t+qhka
-0kM6OofQC& '1mJnV{v]0ByJa${{7N"Ss8,
-:=e$"aFYU$72(
-m_vYjajkLd<kyj@965omSsCiW6*=u<9vu]	kL5pjOupNYq< [K+1(z=bPS`iL7OZ,@
-f"2 mO5$6hDsjs%L Dko8@5yvzwKd(8$3SH!P@$~zzapGd'&:>|m[vf91iHz/yL=&s\zE%B)_$a\Ym&E:no0nf8\W.l"
-% KAfl>{rs#[+mb?x
-JrD+<:/R2Z<"En;AqRp'bc/.ZXs) 1Qig klIhXjk4g}krS	'TBj^
-8]kd$kg^_*
-$[S+(_?C7dv*eT
-ad9[F&q@d EPoI&*H;IwGbDWZv:KY1
-6` {3e.E4  qe/  XHR/@ *XzB^x'AV`:    ]@#
-Nd%J|RrW;j#qF5A2\&Dm=Fd.i,rhsDm3Ux2
-U 
-DW-xYY+MjO ?M\*k EI1L]Nx^(@S!N/*:Fmn+B
-k
-N{rkwv`VwE{Uev4,QFq$W|b]D?g2 HD#p!mecPhC\qT"ud	t^aLb@]DK:=+x,H#&
-qO6_Fkc'Pgs5C(0-n 8I
-@w4I7u?:,8Kt#=Us1I
-JF?&LDh"M0LeGM.3ih,Q(*8&Sb|iGw@!/aTYB*o\0kJw
-SvJJD
-(nv\c.2WZV efl1*>@Po{RY}G,\i{a`f$V-Q>H_y\N(~EuAzP9tCiV<V)\"2%Xi]Wy@f.
-r=/L]xCt{,0\(UPHp4
-gVb:Gg .(D( %utChxiT&Yi"5Tr^N,3+C<7NJ,1,;
-A}62=Q*fKT:8#])I5[x/u:=3R?daNz5 QCR#(~
-tK"8~eqI(82?
- Y(^UvQ#s}v?kO3YF].1_PH-HU'3nHn4]+jjo!\mLN3/kUo6Lfkk$2VyPh"UKEvH8=^!;)Ki',{ _e
-7!D`q[]% 3EA*d	C,M}
-|p('H)jg	xs12)\u?"96,i(o2J //cyFWj0{Ip,_h}qc65'[&z!hHI6\B``EDd(##G4n's7d4QbCQDp*	"W&`_,4s:=)MBiC|)m.[C??[||iuX35B(bHq1muK-47CHQ@cPY=e..r!
-O^h, Rr:)l#B$4eI|L"Sj-v+Y$X/+^-)MNwlbe>sFv Dd
-3n8,2Ok:U\-
-:XFlSR*hB
- wc^ETY@AhICn-Z)%5	I5A[5qX.bv	Ay95A4g
-=k;1=}by
-5n aH`O<{B4*5]3? !VYZ)NHUU<:WX~	^}3:REV<}t\_pPh;J)$x
-)gL3XZrQg:Q$;V Y4uKE5u#!4Pg3$UfG kI2 Lt/R1>O}r"l	cJA&+_waBztjKQTWqbzRHo3<
-'N282(huh%dFeq8+/=bO1.Kx}p'N
-?@[Q8r
-Y5:~~]r,zGE3h;X/6y8CK+E|Ccr&f O$Va
-kV"#tm	~tt^b"Z~7PIFMPfjGm	)>.bk!}{!R8;`V&um)=rcSi]!/W:Ml}{dz#lV@C[&`-DBX_a75A'`yVX9|
-JzF6KF 1Mj&q:
->]x0V	s1" f+;1E$:{j2T-<G=?aC/&b'b9=v8zHmaivH470$u&mb0*}I5h}7 A	g
-/3S1< ,;NaCY6lp@,;;jgcjmZPnO;Y?RtR,8FI HcoaI\bhNjj==0](F +" Cr"eJwV&<&q[EC,5,
-A](& yl*Cn`!C9L]tQv=r43 :jr~Bk{Z9E, )
-ffe|('A6(X<sM{9jwe!P%[EZ%Eh&$Za rIG1\x0iY:kL)Tt-#U3T^5Z1e6GnFa t?w8=TH?f=SP((`E+^vv;s7	@R 2RXw	.Xi04rKzK773
-yrd;WB^k*Q],&>)7wxsVq.)n#_h$k`ZCg~>A+u4g1b.E1C	IUtD1a/I8E9J@c~yMlyvCtQvzaBpk/j^-IR)3kE1FObir(<QuVkW	~I`k	@'e!M_k}3VX^}OP7"ti4~BPJO67?{Heo6t"
-} Pg=RSf(  Txq`TGd
-wqB?	}dG)q9.g2,4Px9>|,Z|PP6n"|"%wMD Z@g 7?f7
--orPBIA,FS{@wS9v0E''D80/@Q$rI@)yl2kvPHe%+>gCz;A}LQc#p/\9,tPF_$H	C>xOe 
-jx<$/x:/=Y Z<'?.pX'@+ #=3'R8 AqA6xFrfp=Sa_Br`r+^<z<j_OIBL>{Lm1t`QrQM<h2S`Yu,\*U+O}pe6\'MHRo@Gf1>Qtl6d%*
-	_q:jZAJ
-oFJnL2Uk$T"4D{q>>ZxkgT'\EBBO3Xu1(*<o1YX;bl|@%7C&W	,0z:p@]6(TruJw+jTZDj6S6$Z,Z!<]I9<ZXj%	R#>A]BL7irn5Cum/M_Q`]uM,h
-G09V\8W\aT#2s)@#P>`qQp"]cILSq+:fEuH8Iz2s`a"~K=BUQg@o	rYYB
-f
-AUWR%Mb;h15\'D=YyO&wh>
-lU&?/Lfw
-"b
-V	).[
-:q~
-iM$-m/$;e .>pI1%SAn`Nmk0mX  & 6??	t 15	7{`OnXo.;Cj%K(
-)dIY`A6Ll(Uk.5&ty`;$){ZiO0%Y`hW@9&N58+el#(yJ]-K=C* 0U&`Q8^Cr9>"h="BIorQY+O'](97ggIv/bF~'I|p I4tbS9J;5}B{f)LxdX.i ;pLr;B!K%B 0 
-(J^,`0wO9kEpI`~;9;sT$ -Y-29h,(/[R~N	
-y/1)	Xw^3H*PKL39
-:b%1H@8feT
-`qPj#V?~An'&x8db-/~M`,U45[afkrl7H@O~x8PPM~iF|`QJk!T2cE0MHAFnW\),v_O&YxTC"&;(|K"QQ]Di:|DQ>8fDL6_voPte6cq*@VLst)yTJa@HE3Fc%1 I5!S&U3m
-|;g!!D_MDF=|W)rQ}
-<-f{Hw*}f'E/!;KaDpjkMgc
-D\  6:~&/W7}
-JVBgf>>U89OX&}D);%`
-P~ls-gQ@z| 'hBs4>XpT-%+ZRT_JP;9ak3Jo'J`*(de;'rA~(m
-',4
-"P6lPQOl,N9EZK&~/9}.9Bjuj[ 'ruh@UMn7D
-yTt.\arl76&8VQ.&'yhte9=$>"taZ	I#KG6>yL|TUY@U=@>eQ5:xI`F?p:/c3s!&4<rden%4 :|gkFT=6)4g=|	X;l I >jDaFxxRQOe%&3QZ
-LJh[8.yyDP5SI:N dg,.|%?p9aB7l;)= SLksNr
-bYq9.MAB
-]6jE]dx~]qUcY|HO
-OyE2xXF}<o4|bcg*vynQ%j#4}FY
-jV6F<%/AYVelPHoA"L #
-BH	W1h* 'sr0;_]6? 
-2z`Hpe,%um/ujz5VI~}xx}qLN@wbo8Yo+rzm}P`USCG%g5Uu>SFw~O%y/A6n `PE"D!9j54
-QKl:*x0WI0Ro(h	C.v{IZDlwMSul#-yIFd5erVxpdT6}`Al/H+`{!HGpg>{-kpG=#*OM:.uX81<GNM(P
-bf^j#E[wKPQ1b ;-*2v^n"rxn8=
-U,- q0vr0I[zk$mK/&UqO_b41x$'I-=:Do[~#nS2|u}EA ^{) {ovU`3Y  }_U^hvPz6X<I=eKK.YE z!4@.8}pm#xC9_7M]^K'6[}Ws"<|&Y[o({_l
-Z`5j<NRkj6lK"W^u_v&/(^93vz+ih}nh*$m!\}&&s0/
-dofH"\Dk]G$|cedxGAHd|!1u-*$~_Z'	-4Zr\i
-2fehe}^S
-%.0h
-M[=s.soHur"dd)`ii>m9b -tKxXfr4k
-CI'K0:)8*;ntb
-3?zC4
-D/71O CAV+V!@Nt3=(UJo EQ61zrqwAMm]8
-}j;kIC7$R7j7G6=$Nz5^A^POy';
-/_Dmmm0'8#   ?Q}KrCG9k.xb}OL6y!iFll>Kaj [g*@"PKK;lm]R,>H.+A#U68A5"eP3s*!2"p#F*RGJl5%hW
-6	q}\/./OTZS4uJ
-B([[Qz3'1IhZ_!! OtNk4Pa{*31] <-Ad3}+-7H KjM=Byt&!%c*.ni3o< +6}u\NCa*>u ]%v	<(HZuX)@^`p('=I,(F'oi*	ro&*gRqx6b|gh5=<Z\blV K\}H4>8
-~C)5;7cUmHb|^'jkj2%)mhc*IdgH0fbci8Tmgfb%&f>=clw7jYb.h/3j$
-Jbe@cV*?h9`I#U>_5a5fZW|+g/5gp:EZfY[oa LC ,X13^XLFUoU.`e8 wVZ<[%ER/jnGO_~(WsI/pj1
-+Dw;G\q*4)j[?-beOLm:H#AA-$8{DEut[WQ\
-(2UGyU{N3t/&@u%`S-FlF9H?=vb1'tu 5cT;J)Cg\J8x#`k!cfUtn[mjOn3K~2zh3NV9L*$q/%c=X+4	/N{vSU0b{uM|pr|7;!+0!y-m!
-u(Ggl7:GPfj^9a8d>^E)\1nnP\)l=9gnmwiEpF8
-; ;Ds&8Y;;=^?!g@- 
-/=,lBH^x\0rP |:@Z
-#&oK!,iiN]VVch{5{bW&f{z X
-rytfYpA)[X3=!gK1CLhSv?BC
-??kKyf9Ff@plY5VWykPA	5
-\G|Y(
-^FU(W.Cl2u,|0%'aiyQ|-v[N9U>/`%jC\M ak*M	=](Vb =gh
- fX $H|"*H>F'7$M:}e)
-mSss^[0Kt.;yY,htYoQY|	L{=pHX#JQj!%71OCi:/I"K$Wr' 3ORhCJ+BW#A,t*[p"emlZK?&Nnq_qd}Pew=y#,*l3@*uO
-RV>NMaN 
-I  J0J]hr,3(`Z [\E{
-O
-g	@V}FWN?>fPvV(b6&;:LGJP\r"Q/dXY"J5t1gQ`5
-!IJ9yZgvC?L#b']
-jpfO$IS;GVK
-bk d(X{1)>DG JjdET}\
-OtRPl.<z3qRVt8tN`]l-Y[51qo-=nAr8_yuY<	fSE
-avm9>\7%sXG4gzh(s`b^&
-L`XwhB!PD8-1'JltLo3C%KlL~#I_Ix>['e?YcPLA*\v8RT&$}z,+?h'v8:5r_gq:+X#ejy&-SUY dhq,~[Cr]I[
-mHhe9Qa AD:jlk|?SE`)Q80XX|%bB{A<c\}IgYx>2:8mCGr F l\#	"J0,}Gw4^lN6kCHjV~A>|rTjh{ 3}P,{Q\+lp+ T o?)^odkCn26emmd5*bYbFVlo	6jp=$=~;'{vsT!/4=L=bJ];<$osT0H }	|9Dbi/-'}Sanzu?*%.7@v3_O`SkVahXyvvd?tmwaU\lF;%}swaS5|
-F3ZMh
-\4CG#)+K
-j{ky:R],m s9GGja7gA#t/P?3* CBxch
-`M n+t%kS/06]=reY&aw1@xztN7+_xs b
-'l<w,pV 7$)
-V`8idgQ^Jx"b}Ll|_5|X|IHLyebL}T_f gg_L]bPyQ NY	#(J2ct;9!i63`x&J=P2pM\F<;dAo{Q;i}0cir:MJZ3"D$\%@sV#Sj/u{3
-|	+H3`FK
-<A:tyL8L}DYa@oQT#n
-  3?	vaN7  qW^Y {|f,y  EXIF   Exif  II*                V       ^   (              i    f       H      H            0210          0100                      
\ No newline at end of file
Index: .idea/workspace.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<project version=\"4\">\r\n  <component name=\"AutoImportSettings\">\r\n    <option name=\"autoReloadType\" value=\"SELECTIVE\" />\r\n  </component>\r\n  <component name=\"ChangeListManager\">\r\n    <list default=\"true\" id=\"0e234145-ed98-4431-8100-784099ca4a53\" name=\"Changes\" comment=\"\">\r\n      <change beforePath=\"$PROJECT_DIR$/Java Theory/Java Notes\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/Java Theory/Java Notes\" afterDir=\"false\" />\r\n    </list>\r\n    <option name=\"SHOW_DIALOG\" value=\"false\" />\r\n    <option name=\"HIGHLIGHT_CONFLICTS\" value=\"true\" />\r\n    <option name=\"HIGHLIGHT_NON_ACTIVE_CHANGELIST\" value=\"false\" />\r\n    <option name=\"LAST_RESOLUTION\" value=\"IGNORE\" />\r\n  </component>\r\n  <component name=\"Git.Settings\">\r\n    <option name=\"RECENT_GIT_ROOT_PATH\" value=\"$PROJECT_DIR$\" />\r\n  </component>\r\n  <component name=\"ProjectLevelVcsManager\">\r\n    <ConfirmationsSetting value=\"1\" id=\"Add\" />\r\n  </component>\r\n  <component name=\"PropertiesComponent\"><![CDATA[{\r\n  \"keyToString\": {\r\n    \"git-widget-placeholder\": \"main\"\r\n  }\r\n}]]></component>\r\n  <component name=\"TaskManager\">\r\n    <servers />\r\n  </component>\r\n</project>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/workspace.xml b/.idea/workspace.xml
--- a/.idea/workspace.xml	(revision 7666dc27f6e206e4e9b2d52f3391b893744e1464)
+++ b/.idea/workspace.xml	(date 1748944886378)
@@ -5,6 +5,10 @@
   </component>
   <component name="ChangeListManager">
     <list default="true" id="0e234145-ed98-4431-8100-784099ca4a53" name="Changes" comment="">
+      <change beforePath="$PROJECT_DIR$/.idea/workspace.xml" beforeDir="false" afterPath="$PROJECT_DIR$/.idea/workspace.xml" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/Collection Theory/Images/Collection Hirarchy.webp" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/Java Theory/Images/Abstract class and Interface in java.webp" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/Java Theory/Java Interview questions" beforeDir="false" afterPath="$PROJECT_DIR$/Java Theory/Java Interview questions" afterDir="false" />
       <change beforePath="$PROJECT_DIR$/Java Theory/Java Notes" beforeDir="false" afterPath="$PROJECT_DIR$/Java Theory/Java Notes" afterDir="false" />
     </list>
     <option name="SHOW_DIALOG" value="false" />
@@ -15,15 +19,53 @@
   <component name="Git.Settings">
     <option name="RECENT_GIT_ROOT_PATH" value="$PROJECT_DIR$" />
   </component>
+  <component name="GitHubPullRequestSearchHistory">{
+  &quot;lastFilter&quot;: {
+    &quot;state&quot;: &quot;OPEN&quot;,
+    &quot;assignee&quot;: &quot;Mahesh100&quot;
+  }
+}</component>
+  <component name="GithubPullRequestsUISettings">{
+  &quot;selectedUrlAndAccountId&quot;: {
+    &quot;url&quot;: &quot;https://github.com/Mahesh100/Java_Practice.git&quot;,
+    &quot;accountId&quot;: &quot;600d7dd7-4c01-402a-a95a-9cc752cc7a35&quot;
+  }
+}</component>
+  <component name="ProjectColorInfo">{
+  &quot;customColor&quot;: &quot;&quot;,
+  &quot;associatedIndex&quot;: 5
+}</component>
+  <component name="ProjectId" id="2x5lZ7FJiGvzcytc2qEWvSTTbls" />
   <component name="ProjectLevelVcsManager">
     <ConfirmationsSetting value="1" id="Add" />
+  </component>
+  <component name="ProjectViewState">
+    <option name="hideEmptyMiddlePackages" value="true" />
+    <option name="showLibraryContents" value="true" />
   </component>
   <component name="PropertiesComponent"><![CDATA[{
   "keyToString": {
-    "git-widget-placeholder": "main"
+    "RunOnceActivity.ShowReadmeOnStart": "true",
+    "git-widget-placeholder": "add__java__question",
+    "ignore.virus.scanning.warn.message": "true",
+    "last_opened_file_path": "C:/Users/mahes/OneDrive/Desktop/Java_Practice/Java Theory/Images",
+    "settings.editor.selected.configurable": "preferences.pluginManager"
   }
 }]]></component>
+  <component name="RecentsManager">
+    <key name="CopyFile.RECENT_KEYS">
+      <recent name="C:\Users\mahes\OneDrive\Desktop\Java_Practice\Java Theory\Images" />
+    </key>
+  </component>
+  <component name="SpellCheckerSettings" RuntimeDictionaries="0" Folders="0" CustomDictionaries="0" DefaultDictionary="application-level" UseSingleDictionary="true" transferred="true" />
   <component name="TaskManager">
+    <task active="true" id="Default" summary="Default task">
+      <changelist id="0e234145-ed98-4431-8100-784099ca4a53" name="Changes" comment="" />
+      <created>1747235870292</created>
+      <option name="number" value="Default" />
+      <option name="presentableId" value="Default" />
+      <updated>1747235870292</updated>
+    </task>
     <servers />
   </component>
 </project>
\ No newline at end of file
Index: Java Theory/Java Interview questions
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>\r\n1) What is difference between Abstract class and Interface?\r\n\r\n2) What is difference between Abstraction and Interface ?\r\n\r\n3) What is difference between Exception and Error?\r\n\r\n4) Difference between Checked exception and Unchecked exception\r\n\r\n5) Difference between Final ,Finally and Finalize in java\r\n\r\n6) What is Multi-threading in java?\r\n\r\n7) Can we start Thread twice?\r\n\r\n8) How threads will communicate with each other?\r\n\r\n10)  What is output of following program ?\r\n\r\n      class demo{\r\n      public static void main(String [] args){\r\n      System.out.println('J'+'a'+'v'+'a');                 //sum of ASCII values\r\n         }\r\n        }\r\n      }\r\n\r\n 11) Can you pass the List<String> to a method which accept List<Object>  ?\r\n    -No you can not pass the Lis<String> to a method which accept List<Object> ?\r\n\r\n 12) What is Generics in java?\r\n\r\n 13) What is idempotent method according to HTTP specification?     //GET is the idempotent method\r\n\r\n 14) What is feature branch in Git?\r\n\r\n 15) How to call REST api from your spring boot application?\r\n\r\n 16) When to use Abstract class and when to use Interface in java ?\r\n\r\n 17) What is advantages of Stream API?\r\n\r\n 18) Difference between Runnable and callable interface in java?\r\n\r\n 19)\r\n\r\n --------------------------------------------------------------------------------------------------------------------\r\n # General java questions\r\n   1) What is wrapper class in java?\r\n      - class which converts primitive data types into objects\r\n\r\n   2) Which keyword is used to define constant?\r\n      - Final keyword\r\n\r\n # Constructor in java\r\n   1) What happens if we declare constructor private in java?\r\n      - Class can not be instantiated from out side\r\n\r\n # Static keyword\r\n   1) Can we override static method in java\r\n      - No\r\n\r\n # Multithreading in java\r\n   1) What are ways to implement multithreading in java?\r\n      - By extending thread class\r\n      - By implementing runnable interface\r\n\r\n # Interface\r\n   1) Can interface extends another interface?\r\n      - Yes\r\n\r\n # Unboxing in java\r\n   1) What is unboxing in java?\r\n   - Java compiler automatically converts its wrapper class into corresponding data types in called unboxing in java.\r\n\r\n # Exception in java\r\n\r\n   1) What is unchecked exception in java?\r\n   - Exception that occurs during runtime of program, it is also known as runtime exception.\r\n     Example of unchecked exception are :\r\n     - Arithmetic exception\r\n     - nullPointer exception\r\n     - ArrayIndexOutOfBound exception\r\n\r\n   2) Can try block exits without catch block?\r\n      - No\r\n\r\n # Functional interface\r\n   1) What is functional interface in java?\r\n      - Interface which have only one abstract method\r\n\r\n # Garbage collection in java\r\n\r\n   1) What name of method which performs garbage collection in java?\r\n      - finalize()
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Java Theory/Java Interview questions b/Java Theory/Java Interview questions
--- a/Java Theory/Java Interview questions	(revision 7666dc27f6e206e4e9b2d52f3391b893744e1464)
+++ b/Java Theory/Java Interview questions	(date 1747118670075)
@@ -59,6 +59,35 @@
    1) Can we override static method in java
       - No
 
+ * OOPS CONCEPTS *
+
+ # Inheritance
+
+ # Abstraction
+
+   1] Abstract class in java
+
+   1) What is abstract class in java?
+      - In java abstract class is used to achieve 0 to 100% abstraction.
+      - In abstract class can have both abstract method and concerate methods(Methods with body)
+      - We can create constructor in abstract class to initialize instance variables but we can create object of
+        abstract class.
+
+        Example: public abstract MyClass{
+
+            public void m1(){
+
+            }
+
+            public abstract void m2();
+
+            int x;    //instance varable
+
+            public MyClass(){
+             int x = 10;
+            }
+        }
+
  # Multithreading in java
    1) What are ways to implement multithreading in java?
       - By extending thread class
@@ -90,5 +119,5 @@
 
  # Garbage collection in java
 
-   1) What name of method which performs garbage collection in java?
+   1) What is the name of method which performs garbage collection in java?
       - finalize()
\ No newline at end of file
