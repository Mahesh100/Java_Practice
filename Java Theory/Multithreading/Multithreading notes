# Multi threading in java

- By default JVM will provide name to thread automatically
- We can set name to any thread using Thread.currentThread().setName("Mahesh");   //Mahesh is name of thread here


# Multitasking
- Performing multiple task at single time is called multitasking
- Multitasking increases the performance of CPU

- We can achieve multitasking by two ways :

    1) Process based multitasking  (Multi Processing)
    2) Thread based multitasking   (Multi Threading)

 1) Process Based multitasking (Multi Processing)
 - When one system is connected to multiple processors in order to complete the task.
 - It is best suitable at system level

   # Process (Program)[Ex VLC] :
   - Process is combination of multiple small small task (threads)


 2) Thread based multitasking (Multi threading)

 # Thread:
   - Executing multiple threads at same time is called multithreading


   Example :

   class VLC{
        public static void main(String [] args)
        {

        }

        class Video   (Thread 1)
        {
            void playVideo()
            {

            }
        }

        class Music  (Thread 2)
        {
            void startMusic()
            {

            }
        }
   }

   - Multi threading is best suitable at programming level
   - In java we have predefine API's for multithreading so we don't need to do internal coding, we have to implement only classes and interfaces
     to achieve multithreading in java

     Example : Thread class
               Runnable interface
               Thread Group class
               Concurrency package
               Thread pool (Executor framework)


----------------------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------------------

# Difference between process and Thread

                 Process                                                                                    Thread

 - The executing program is called process                                              - Sub part of process is called thread
 - Process is heavy weight                                                              - Thread is light weight.
 - Process takes more time for context switching                                        - Thread takes less time for context switching
 - Process takes more time for inter process communication.                             - Thread takes less time for inter thread communication
 - Each process has different address space                                             - Thread share same address space.
 - Process are not dependent on each other                                              - Threads are dependent on each other
 - Process does not require synchronization                                             - Threads may require synchronization
 - Process consume more resources                                                       - Thread Consumes less resources
 - Process require more time for creation                                               - Threads takes less time for creation
 - Process takes more time for termination                                              - Thread takes less time for termination



--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

# Steps to create thread in java

1) Step: 1  Define class by extending Thread class

  public class Test extends Thread
  {
        Step: 2  Override run() method
        public void run()
        {
            //Tast
            System.out.println("Thread task");
        }

        public static void main(String [] args)
        {
            Step 3: Create Object of class
            Test t = new Test();

            Step: 4 Invoke run() method using object.start() method

            t.start();
        }
  }

--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------



 # Thread class constructor and  methods

 # Syntax

 public class Thread implements Runnable
 {

    # Constructors

    # Basic thread constructor

    1) Default constructor
    Thread();

    2) Second constructor
    Thread(Runnable target)

    3) Third constructor
    Thread(String name)      //For providing thread name

   # Thread group related constructor

    4) Fourth constructor  (For runnable interface)
    Thread(Runnable target, String name)

    5) Fifth constructor  (Related thread group)
    Thread(ThreadGroup tg, Runnable target)

    6) Sixth constructor
    Thread(ThreadGroup tg, String name)

    7) Seventh Constructor
    Thread(ThreadGroup tg, Runnable target, String name)

    8) Eighth constructor
    Thread(ThreadGroup tg, Runnable target, String name, long StackSize)

    # Methods

    # Basic methods
    1) run() method
    2) start() method  //It is synchronise method

    # Naming method
    3) currentThread() method  (static method and provides thread reference)    [These are Native method]  {Native methods are the one whose
    4) isAlive()              //  return boolean value                          [These are Native method]   implementation is not in java language but
    5) getName()                                                                                            in some other language}
    6) setName(String name)

    # Daemon thread methods
    7) isDemon()
    8) setDemon(boolean value)

    # Priority based methods
    9)  getPriority()
    10) setPriority(int value)

    # Preventing thread execution methods
    11) sleep() method
    12) yield()
    13) join()      //Deprecated suspend() , resume() destroy()

    # Thread Interrupting  methods
    14) interrupt(), isInterrupt()  interpreted()

    # Inter thread communication method
    # Present in object class

    1) wait()
    2) notify()
    3) notifyAll()

 }


--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


 # Get Current Thread

   class Test extends Thread
   {
   public void run()
   {
   System.out.println("Task");
   }
}
   public static void main(String [] args)
   {
        System.out.println(Thread.currentThread().getName());
        Thread.currentThread().setName("Thread-1");

        Test t = new Test();
        t.start();
   }


--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

 # Daemon Thread in java

 - Threads which run in background of another thread
 - Use: Daemon thread provides service to current thread

 Example:
 Garbage Collector, Finalizer, Attach Listener, Signal dispatcher

  -Garbage collector is service thread(Daemon) which executes in background which provides the service
   as it will restrict main thread from any potential memory problem.
   It will delete waste object and free the memory

# Methods in daemon thread

 # public final void setDaemon(boolean value)   //return type void

 # public final boolean isDaemon()     //return boolean value

 class Test extends Thread
 {
     public void run()
     {
        System.out.println("Child Thread");
     }

     public static void main(String [] args)
     {
             System.out.println("Main Thread");

             Test t = new Test();
             t.setDaemon(true);   //always create before start() method
             t.start()
     }
 }


 # Cases :

 Case 1:
 - We have to create daemon thread before start() method
 - If we create thread after start() method then it will throw runtime exception as IllegalStateException
 - We can not create main thread as demon thread as main thread already started and
   we have to create daemon thread before starting the thread.

 - Life of daemon thread depends up on another thread( on whose background it is running(Parent thread))

 - Daemon thread inherits the properties from its parent thread

 - JVM is not dependent on daemon thread.

 - Daemon should have low priority, but we can change it according to our need


--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

# Thread Priorities

- Priorities are represented in the form of Integer values and ranges from 1 to 10
  Where,

  1  is MIN_PRIORITY
  5  iS NORM_PRIORITY
  10 is MAX_PRIORITY   //These constants are provided by java

  //Not priority for thread (Not exists)
  0, < 1, >10, LOW_Priority, Normal_Priority, Maximum_priority, High_PRIORITY

- Priority of thread is a integer number given to thread.
- Every thread has its own priority
- JVM sets the priority to each thread.
- According to priority JVM will allocate processor to thread
- Priorities are inherited from parent thread
- By default priority of main thread is 5 (NORM_PRIORITY)
- If multiple threads have same priority then it is depend on JVM to give first priority to threads
- Windows does not supports priority
- Priority depends up on platform

# Methods for Priority

public final void setPriority()

public final int getPriority()


--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

# Prevent Thread Execution method in java

1) sleep() method

- In thread class we have two sleep methods
  means sleep() method overloaded

  Method 1

  public static native void sleep(long mili) throws InterruptedException

  Method 2

  public static void sleep(long miliSeconds, int nanoSeconds) throws InterruptedException

  Both are static methods so we can call both methods directly from thread class

  class Test
  {
    public static void main(String [] args)
    {
    for(int i=1; i<=5;i++)
    {
    try{
        Thread.sleep(1000);
      System.out.println(i);
      }
      catch(Exception e)
      {
      System.out.println(e);
      }
    }
    }
  }

- sleep() method will throw InterruptedException

- While thread is in sleep mode it does not release lock

--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

 # yield() method

 - This method will stop current running/executing thread and give chance to other thread for execution

 Working of yield method

 - In java 5, yield method used sleep() method internally
 - In java 6, Thread provided the hint to thread scheduler then it depends on thread scheduler to accept or ignore the hint

# Method

public static native void yield();

- output may be different each time

public class Test extends  Thread{

    public void  run(){
        for(int i=0; i<=5; i++){
            System.out.println(Thread.currentThread().getName());
          //  System.out.println(i);
        }


    }

    public static void main(String[] args) {
        Test t = new Test();
        t.start();

        for(int i=0; i<5; i++)
        {
            Thread.yield();
            System.out.println("Main Thread");
        }
    }
}


--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

# join() method in multi threading

- join() method is used when if thread wants to wait for another thread to complete its task

# Methods : (Overloaded)

1) public final void join() throws InterruptedException{}

2) public final synchronized void join(long mili) throws InterruptedException{}

3) public final synchronized void join(int mili, long nano) throws InterruptedException{}

public class  Test extends Thread{

    public void run()
    {
        try{
            for(int i=1; i<=5; i++)
            {
                System.out.println("Child Thread");
                Thread.sleep(1000);
            }
        }catch(Exception e)
        {
            System.out.println(e);
        }
    }

    public static void main(String [] args) throws InterruptedException {
        Test t = new Test();
        t.start();
        t.join();
        try{
            for(int i=1; i<=5; i++)
            {
                System.out.println("Main Thread");
                Thread.sleep(1000);

            }
        }catch(Exception e)
        {
            System.out.println(e);
        }

    }
}

--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

 # Difference between sleep() yield() and join() method

  - All three methods will temporary stops the execution

  Property                               sleep()                                                              yield()                                                                       join()

1) Purpose               If any thread does not want to perform operation                 It stops current executing thread and provides chance                      If one thread wants to wait for another thread to complete its
                         for particular time                                              of another thread of same priority or higher priority to execute           task

2) Example               Timer,PPT                                                        Licence department

3) How the thread       -Invokes automatically as per given time period                   Automatically invoke by thread scheduler                                    Automatically invoked after completion of another thread task
   invoke again         -If thread is interrupted                                                                                                                     After completion of given time period
                                                                                                                                                                      If thread is interrupted

4) Methods              native sleep(long mili)                                                   yield()                                                                    join()
                        sleep(long mili, int nano)                                                                                                                    join(long mili)
                                                                                                                                                                      join(long mili, int nano)

5) If overloaded        Yes                                                                No                                                                          Yes

6) Exception            InterruptedException                                               N/A                                                                         InterruptedException

7) is final()           No                                                                 No                                                                          Yes

8) is static            Yes                                                                Yes                                                                         No

9) is Native            Yes                                                                Yes                                                                         No


----------------------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------------------

 # interrupting methods in java

 - It is use to interrupt an existing thread
 - Interrupt method works only when the thread is in sleep() or wait() state
 - If thread is not is in sleeping or waiting state then calling interrupt method will perform normal behavior
 - Interrupt method always throws InterruptedException (Checked exception/ handle using try-catch block)
 - public void interrupt()

 Example :

 class Test extends Thread
 {
      public void run()
      {
     try {
                 for (int i = 1; i <= 5; i++)
                 {
                     if(i>3)
                     {
                         Thread.interrupted();
                     }else
                     {
                         System.out.println(i);

                       //  Thread.sleep(3000);
                     }
                 }
        }catch(Exception e)
        {
          System.out.println(e);
          }
        }

        public static void main(String [] args)
        {
          Test t = new Test();
          t.start();
        }
      }
----------------------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------------------

# Synchronization in java

 # Program without Synchronization

public class BookTheaterSeat {
    int total_seats = 10;
    void bookSeat(int seats)
    {
        if(total_seats>=seats)
        {
            System.out.println("Seats booked successfully");
            total_seats = total_seats-seats;
            System.out.println("Left seats: "+total_seats);
        }else {
            System.out.println("Seats can not be booked");
            System.out.println("Seats Left "+total_seats);
        }
    }
}


public class MovieBookApp extends Thread{

   static BookTheaterSeat b;
   int seats;
    public void run(){

        b.bookSeat(seats);

    }

    public static void main(String[] args) {
            b= new BookTheaterSeat();

            MovieBookApp deepak = new MovieBookApp();
            deepak.seats=7;
            deepak.start();

            MovieBookApp mahesh = new MovieBookApp();
            mahesh.seats=12;
            mahesh.start();

            MovieBookApp amit = new MovieBookApp();
            amit.seats = 6;
            amit.start();
    }
}


- Synchronization is process by which we can control the accessibility of multiple threads of particular resource.
- Without synchronization Data inconsistency and multiple thread interference problem may occur
- Advantages of synchronization :
        Avoid data inconsistency problem
        No thread interference

-Disadvantages of Synchronization:
    Increase the waiting time period of threads
    Create performance problems

 # Synchronization can be archived by using two ways:

 1) Process Synchronization
 2) Thread Synchronization

   2) Thread Synchronization divided into two parts:
      i)  Mutual Exclusive
      ii) Cooperation
----------------------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------------------


 # Synchronize methods in java

 1) Synchronized method
    - Any method with synchronized keyword is known as synchronized method
    - In java every object have unique lock
    - In object there are two areas as
          i) Synchronized area
          ii) Non-Synchronized area


2) Synchronize block in java

 - Need Of Synchronize block:
   - In synchronize block lock is on object level
   - If we want to make only particular lines of code synchronise
   - Apply synchronization at only impacted area
   - It reduces thread waiting time
   - Scope of synchronise() block is less than scope of synchronise method


 3) Static Synchronization :
    -In static synchronization lock is at class level
